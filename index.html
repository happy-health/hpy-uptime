<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Happy Health - Dependency Status</title>
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --border: #30363d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --green: #3fb950;
      --yellow: #d29922;
      --orange: #db6d28;
      --red: #f85149;
      --blue: #58a6ff;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
    }

    .header {
      max-width: 1100px;
      margin: 0 auto 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header h1 { font-size: 1.5rem; font-weight: 600; }

    .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .refresh-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .refresh-bar button {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text-muted);
      padding: 0.3rem 0.7rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .refresh-bar button:hover { color: var(--text); border-color: var(--text-muted); }

    .summary {
      max-width: 1100px;
      margin: 0 auto 1.5rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .summary-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.5rem;
      flex: 1;
      min-width: 140px;
      text-align: center;
    }

    .summary-card .count { font-size: 2rem; font-weight: 700; line-height: 1.2; }
    .summary-card .label { font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem; }

    .count-operational { color: var(--green); }
    .count-degraded { color: var(--yellow); }
    .count-outage { color: var(--red); }
    .count-unknown { color: var(--text-muted); }

    table {
      width: 100%;
      max-width: 1100px;
      margin: 0 auto;
      border-collapse: collapse;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    thead th {
      text-align: left;
      padding: 0.75rem 1rem;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
      background: var(--surface);
    }

    tbody tr { border-bottom: 1px solid var(--border); }
    tbody tr:last-child { border-bottom: none; }
    tbody tr:hover { background: rgba(255,255,255,0.02); }

    td { padding: 0.7rem 1rem; font-size: 0.9rem; vertical-align: middle; }

    .service-name { font-weight: 500; display: flex; align-items: center; gap: 0.5rem; }
    .service-name a { color: var(--text); text-decoration: none; }
    .service-name a:hover { color: var(--blue); }

    .status-dot {
      width: 10px; height: 10px; border-radius: 50%;
      display: inline-block; flex-shrink: 0;
    }

    .dot-operational { background: var(--green); }
    .dot-degraded { background: var(--yellow); }
    .dot-partial { background: var(--orange); }
    .dot-major { background: var(--red); }
    .dot-loading { background: var(--text-muted); animation: pulse 1.5s infinite; }
    .dot-error { background: var(--border); }

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

    .status-text { font-size: 0.85rem; }
    .status-text.operational { color: var(--green); }
    .status-text.degraded { color: var(--yellow); }
    .status-text.partial { color: var(--orange); }
    .status-text.major { color: var(--red); }
    .status-text.loading { color: var(--text-muted); }
    .status-text.error { color: var(--text-muted); }

    .category-label { font-size: 0.75rem; color: var(--text-muted); }
    .updated-at { font-size: 0.8rem; color: var(--text-muted); }

    .proxy-note {
      max-width: 1100px;
      margin: 1rem auto 0;
      padding: 0.75rem 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .proxy-note code {
      background: rgba(255,255,255,0.06);
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-size: 0.75rem;
    }

    @media (max-width: 700px) {
      body { padding: 1rem; }
      .header { flex-direction: column; align-items: flex-start; }
      td, th { padding: 0.5rem 0.6rem; font-size: 0.8rem; }
    }
  </style>
</head>
<body>

<div class="header">
  <h1>Happy Health &mdash; Dependency Status</h1>
  <div class="header-right">
    <div class="refresh-bar">
      <span id="countdown">Refreshing in 60s</span>
      <button onclick="fetchAll()">Refresh now</button>
    </div>
  </div>
</div>

<div class="summary">
  <div class="summary-card">
    <div class="count count-operational" id="count-up">-</div>
    <div class="label">Operational</div>
  </div>
  <div class="summary-card">
    <div class="count count-degraded" id="count-degraded">-</div>
    <div class="label">Degraded</div>
  </div>
  <div class="summary-card">
    <div class="count count-outage" id="count-outage">-</div>
    <div class="label">Outage</div>
  </div>
  <div class="summary-card">
    <div class="count count-unknown" id="count-unknown">-</div>
    <div class="label">Unknown</div>
  </div>
</div>

<table>
  <thead>
    <tr>
      <th>Service</th>
      <th>Status</th>
      <th>Description</th>
      <th>Category</th>
      <th>Last Checked</th>
    </tr>
  </thead>
  <tbody id="status-body"></tbody>
</table>

<div class="proxy-note" id="proxy-note" style="display:none">
  Some services block browser requests (CORS). To enable all services, deploy a
  <a href="https://github.com/Zibri/cloudflare-cors-anywhere" target="_blank" style="color:var(--blue)">Cloudflare Worker CORS proxy</a>
  and set <code>?proxy=https://your-worker.workers.dev</code> in the URL.
</div>

<script>
// ── Configuration ───────────────────────────────────────────────────────

// Optional CORS proxy from URL param: ?proxy=https://your-worker.workers.dev
const PROXY_URL = new URLSearchParams(location.search).get("proxy") || "";

const SERVICES = [
  // ── Statuspage API (direct, CORS-friendly) ────────────────────────────
  {
    name: "GitHub",
    category: "Source Control",
    statusUrl: "https://www.githubstatus.com",
    fetch: fetchStatuspage("https://www.githubstatus.com/api/v2/status.json"),
  },
  {
    name: "Bitbucket",
    category: "Source Control",
    statusUrl: "https://bitbucket.status.atlassian.com",
    fetch: fetchStatuspage("https://bitbucket.status.atlassian.com/api/v2/status.json"),
  },
  {
    name: "npm Registry",
    category: "Package Registry",
    statusUrl: "https://status.npmjs.org",
    fetch: fetchStatuspage("https://status.npmjs.org/api/v2/status.json"),
  },
  {
    name: "PyPI",
    category: "Package Registry",
    statusUrl: "https://status.python.org",
    fetch: fetchStatuspage("https://status.python.org/api/v2/status.json"),
  },
  {
    name: "Shopify Payments",
    category: "Payments",
    statusUrl: "https://www.shopifystatus.com",
    fetch: fetchStatuspage("https://www.shopifystatus.com/api/v2/status.json"),
  },
  {
    name: "Datadog",
    category: "Observability",
    statusUrl: "https://status.datadoghq.com",
    fetch: fetchStatuspage("https://status.datadoghq.com/api/v2/status.json"),
  },
  {
    name: "Sentry",
    category: "Observability",
    statusUrl: "https://status.sentry.io",
    fetch: fetchStatuspage("https://status.sentry.io/api/v2/status.json"),
  },
  {
    name: "Customer.io",
    category: "Communications",
    statusUrl: "https://status.customerio.com",
    fetch: fetchStatuspage("https://status.customerio.com/api/v2/status.json"),
  },
  {
    name: "Twilio",
    category: "Communications",
    statusUrl: "https://status.twilio.com",
    fetch: fetchStatuspage("https://status.twilio.com/api/v2/status.json"),
  },

  // ── Direct APIs with CORS (non-Statuspage) ────────────────────────────

  {
    name: "GitLab",
    category: "Source Control",
    statusUrl: "https://status.gitlab.com",
    fetch: fetchAtomFeed("https://status.gitlab.com/pages/5b36dc6502d06804c08349f7/rss", false),
  },
  {
    name: "Oracle Cloud",
    category: "Cloud Infrastructure",
    statusUrl: "https://ocistatus.oraclecloud.com",
    fetch: fetchAtomFeed("https://ocistatus.oraclecloud.com/api/v2/incident-summary.rss", false),
  },
  {
    name: "Stytch",
    category: "Authentication",
    statusUrl: "https://status.stytch.com",
    fetch: fetchInstatus("https://stytch.instatus.com/summary.json"),
  },
  {
    name: "Eve",
    category: "Partner",
    statusUrl: "https://status.eve.co",
    fetch: fetchUptimeRobot("https://status.eve.co/api/getMonitorList/BQLq3SDoBo"),
  },

  // ── Requires CORS proxy (no browser-friendly API) ─────────────────────

  {
    name: "Stripe",
    category: "Payments",
    statusUrl: "https://status.stripe.com",
    fetch: fetchStripe("https://status.stripe.com/current"),
    needsProxy: true,
  },
  {
    name: "PayPal",
    category: "Payments",
    statusUrl: "https://www.paypal-status.com",
    fetch: fetchAtomFeed("https://www.paypal-status.com/feed/atom", true),
    needsProxy: true,
  },
  {
    name: "AWS",
    category: "Cloud Infrastructure",
    statusUrl: "https://health.aws.amazon.com/health/status",
    fetch: fetchAtomFeed("https://health.aws.amazon.com/health/status", true),
    needsProxy: true,
  },
  {
    name: "Microsoft Azure",
    category: "Cloud Infrastructure",
    statusUrl: "https://azure.status.microsoft/en-us/status",
    fetch: fetchAtomFeed("https://azurestatuscdn.azureedge.net/en-us/status/feed/", true),
    needsProxy: true,
  },
  {
    name: "Google Cloud",
    category: "Cloud Infrastructure",
    statusUrl: "https://status.cloud.google.com",
    fetch: fetchAtomFeed("https://status.cloud.google.com/feed.atom", true),
    needsProxy: true,
  },
  {
    name: "Apple Developer",
    category: "Mobile Platforms",
    statusUrl: "https://developer.apple.com/system-status/",
    fetch: fetchApple("https://www.apple.com/support/systemstatus/data/developer/system_status_en_US.js"),
    needsProxy: true,
  },
];

// ── State ───────────────────────────────────────────────────────────────

const serviceState = {};
let countdownSeconds = 60;
let countdownTimer = null;

// ── Fetcher factories ───────────────────────────────────────────────────

function proxyWrap(url, needsProxy) {
  if (needsProxy && PROXY_URL) {
    const sep = PROXY_URL.includes("?") ? "&" : "?";
    return PROXY_URL + sep + "url=" + encodeURIComponent(url);
  }
  return url;
}

function fetchStatuspage(apiUrl) {
  return async function () {
    const resp = await fetch(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    const indicator = data.status?.indicator || "none";
    const description = data.status?.description || "Unknown";
    const levelMap = { none: "operational", minor: "degraded", major: "partial", critical: "major" };
    return { level: levelMap[indicator] || "operational", description };
  };
}

function fetchInstatus(apiUrl) {
  return async function () {
    const resp = await fetch(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    const status = data.page?.status || "UNKNOWN";
    const levelMap = { UP: "operational", HASISSUES: "degraded", UNDERMAINTENANCE: "degraded" };
    return {
      level: levelMap[status] || "error",
      description: status === "UP" ? "All Systems Operational" : status,
    };
  };
}

function fetchUptimeRobot(apiUrl) {
  return async function () {
    const resp = await fetch(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    const counts = data.statistics?.counts || {};
    if (counts.down > 0) {
      return { level: "major", description: `${counts.down} of ${counts.total} monitors down` };
    }
    return {
      level: "operational",
      description: data.statistics?.count_result || "All monitors up",
    };
  };
}

function fetchStripe(apiUrl) {
  return async function () {
    const url = proxyWrap(apiUrl, true);
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    const levelMap = { up: "operational", degraded: "degraded", down: "major" };
    return {
      level: levelMap[data.largestatus] || "error",
      description: data.message || "Unknown",
    };
  };
}

function fetchAtomFeed(feedUrl, needsProxy) {
  return async function () {
    const url = proxyWrap(feedUrl, needsProxy);
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    const parser = new DOMParser();

    // Try XML first (RSS/Atom)
    const xml = parser.parseFromString(text, "application/xml");
    const parseError = xml.querySelector("parsererror");

    if (!parseError) {
      // Look for recent entries (within 24h)
      const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
      const entries = xml.querySelectorAll("entry, item");
      const recentIncidents = [];

      for (const entry of entries) {
        const updated = entry.querySelector("updated, pubDate");
        if (updated) {
          const date = new Date(updated.textContent.trim());
          if (date.getTime() > oneDayAgo) {
            const title = entry.querySelector("title")?.textContent?.trim() || "";
            recentIncidents.push(title);
          }
        }
      }

      if (recentIncidents.length === 0) {
        return { level: "operational", description: "No recent incidents" };
      }

      const latest = recentIncidents[0];
      const level = classifyIncidentTitle(latest);
      return { level, description: latest };
    }

    // Fallback: parse as HTML and look for status text
    const html = parser.parseFromString(text, "text/html");
    const bodyText = html.body?.textContent || "";
    if (/all systems operational/i.test(bodyText)) {
      return { level: "operational", description: "All Systems Operational" };
    }
    if (/operational/i.test(bodyText)) {
      return { level: "operational", description: "Operational" };
    }

    return { level: "error", description: "Could not parse status" };
  };
}

function fetchApple(apiUrl) {
  return async function () {
    const url = proxyWrap(apiUrl, true);
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();

    // Apple returns JSONP: jsonCallback({...})
    const match = text.match(/jsonCallback\((.+)\)/s);
    if (!match) throw new Error("Could not parse JSONP");

    const data = JSON.parse(match[1]);
    const services = data.services || [];
    const issues = services.filter(
      (s) => s.events?.length > 0 && s.events.some((e) => e.statusType !== "resolved")
    );

    if (issues.length === 0) {
      return { level: "operational", description: "All Developer Services Operational" };
    }
    return { level: "degraded", description: `${issues.length} service(s) with active events` };
  };
}

// ── Helpers ──────────────────────────────────────────────────────────────

function classifyIncidentTitle(title) {
  const t = title.toLowerCase();
  if (/resolved|completed|scheduled/i.test(t)) return "operational";
  if (/major|critical|outage/i.test(t)) return "major";
  if (/partial/i.test(t)) return "partial";
  if (/degraded|elevated|minor|investigating|monitoring/i.test(t)) return "degraded";
  return "degraded"; // default for any active incident
}

function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

function escapeHtml(s) {
  const div = document.createElement("div");
  div.textContent = s;
  return div.innerHTML;
}

// ── Rendering ───────────────────────────────────────────────────────────

function renderTable() {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";

  const sorted = [...SERVICES].sort((a, b) => {
    if (a.category < b.category) return -1;
    if (a.category > b.category) return 1;
    return a.name.localeCompare(b.name);
  });

  for (const svc of sorted) {
    const s = serviceState[svc.name] || { level: "loading", description: "Checking..." };
    const tr = document.createElement("tr");

    const dotMap = {
      operational: "dot-operational", degraded: "dot-degraded", partial: "dot-partial",
      major: "dot-major", loading: "dot-loading", error: "dot-error",
    };

    const timeStr = s.checkedAt ? new Date(s.checkedAt).toLocaleTimeString() : "-";

    tr.innerHTML = `
      <td><div class="service-name"><span class="status-dot ${dotMap[s.level] || 'dot-error'}"></span><a href="${svc.statusUrl}" target="_blank" rel="noopener">${svc.name}</a></div></td>
      <td><span class="status-text ${s.level || 'error'}">${capitalize(s.level || 'error')}</span></td>
      <td>${escapeHtml(s.description)}</td>
      <td><span class="category-label">${svc.category}</span></td>
      <td><span class="updated-at">${timeStr}</span></td>
    `;
    tbody.appendChild(tr);
  }

  updateSummary();
}

function updateSummary() {
  let up = 0, degraded = 0, outage = 0, unknown = 0;
  for (const svc of SERVICES) {
    const s = serviceState[svc.name];
    if (!s || s.level === "loading" || s.level === "error") { unknown++; continue; }
    if (s.level === "operational") up++;
    else if (s.level === "degraded" || s.level === "partial") degraded++;
    else if (s.level === "major") outage++;
    else unknown++;
  }
  document.getElementById("count-up").textContent = up;
  document.getElementById("count-degraded").textContent = degraded;
  document.getElementById("count-outage").textContent = outage;
  document.getElementById("count-unknown").textContent = unknown;
}

// ── Main loop ───────────────────────────────────────────────────────────

async function fetchAll() {
  countdownSeconds = 60;

  // Show proxy note if any service needs a proxy and none is configured
  const needsProxy = SERVICES.some((s) => s.needsProxy);
  document.getElementById("proxy-note").style.display =
    needsProxy && !PROXY_URL ? "block" : "none";

  for (const svc of SERVICES) {
    if (!serviceState[svc.name]) {
      serviceState[svc.name] = { level: "loading", description: "Checking...", checkedAt: null };
    }
  }
  renderTable();

  const promises = SERVICES.map(async (svc) => {
    // Skip proxy-dependent services if no proxy configured
    if (svc.needsProxy && !PROXY_URL) {
      serviceState[svc.name] = {
        level: "error",
        description: "Needs CORS proxy",
        checkedAt: Date.now(),
      };
      renderTable();
      return;
    }

    try {
      const result = await svc.fetch();
      serviceState[svc.name] = { ...result, checkedAt: Date.now() };
    } catch (e) {
      serviceState[svc.name] = {
        level: "error",
        description: `Failed: ${e.message}`,
        checkedAt: Date.now(),
      };
    }
    renderTable();
  });

  await Promise.allSettled(promises);
  renderTable();
}

function startCountdown() {
  if (countdownTimer) clearInterval(countdownTimer);
  countdownSeconds = 60;
  countdownTimer = setInterval(() => {
    countdownSeconds--;
    document.getElementById("countdown").textContent = `Refreshing in ${countdownSeconds}s`;
    if (countdownSeconds <= 0) fetchAll();
  }, 1000);
}

// ── Init ────────────────────────────────────────────────────────────────

fetchAll();
startCountdown();
</script>
</body>
</html>

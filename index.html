<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Happy Health — Dependency Status</title>
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --surface-hover: #1c2128;
      --border: #30363d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --green: #3fb950;
      --green-muted: #238636;
      --yellow: #d29922;
      --orange: #db6d28;
      --red: #f85149;
      --blue: #58a6ff;
      --bar-empty: #21262d;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem 1.5rem;
    }

    .container { max-width: 920px; margin: 0 auto; }

    /* ── Header ──────────────────────────────────────────── */

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .header h1 { font-size: 1.4rem; font-weight: 600; }

    .header-right {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      color: var(--text-muted);
      font-size: 0.82rem;
    }

    .header-right button {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text-muted);
      padding: 0.3rem 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: color 0.15s, border-color 0.15s;
    }

    .header-right button:hover { color: var(--text); border-color: var(--text-muted); }

    /* ── Overall banner ──────────────────────────────────── */

    .overall-banner {
      padding: 1rem 1.25rem;
      border-radius: 8px;
      margin-bottom: 1.25rem;
      font-weight: 600;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      border: 1px solid;
    }

    .overall-banner .banner-dot {
      width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0;
    }

    .banner-operational { background: rgba(63,185,80,0.08); border-color: rgba(63,185,80,0.3); color: var(--green); }
    .banner-operational .banner-dot { background: var(--green); }
    .banner-degraded { background: rgba(210,153,34,0.08); border-color: rgba(210,153,34,0.3); color: var(--yellow); }
    .banner-degraded .banner-dot { background: var(--yellow); }
    .banner-outage { background: rgba(248,81,73,0.08); border-color: rgba(248,81,73,0.3); color: var(--red); }
    .banner-outage .banner-dot { background: var(--red); }
    .banner-loading { background: var(--surface); border-color: var(--border); color: var(--text-muted); }
    .banner-loading .banner-dot { background: var(--text-muted); animation: pulse 1.5s infinite; }

    /* ── Summary cards ───────────────────────────────────── */

    .summary {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.75rem;
      flex-wrap: wrap;
    }

    .summary-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.85rem 1.25rem;
      flex: 1;
      min-width: 120px;
      text-align: center;
    }

    .summary-card .count { font-size: 1.75rem; font-weight: 700; line-height: 1.2; }
    .summary-card .label { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.15rem; }

    .count-operational { color: var(--green); }
    .count-degraded { color: var(--yellow); }
    .count-outage { color: var(--red); }
    .count-unknown { color: var(--text-muted); }

    /* ── Category groups ─────────────────────────────────── */

    .service-group { margin-bottom: 1.75rem; }

    .group-title {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      padding-left: 0.25rem;
    }

    .group-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    /* ── Service row ─────────────────────────────────────── */

    .service-row {
      padding: 0.85rem 1.15rem;
      border-bottom: 1px solid var(--border);
      transition: background 0.1s;
    }

    .service-row:last-child { border-bottom: none; }
    .service-row:hover { background: var(--surface-hover); }

    .service-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.35rem;
    }

    .service-name {
      font-weight: 500;
      font-size: 0.9rem;
    }

    .service-name a {
      color: var(--text);
      text-decoration: none;
      transition: color 0.15s;
    }

    .service-name a:hover { color: var(--blue); }

    .status-badge {
      font-size: 0.75rem;
      font-weight: 500;
      padding: 0.15rem 0.55rem;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .status-badge .badge-dot {
      width: 7px; height: 7px; border-radius: 50%;
    }

    .badge-operational { color: var(--green); background: rgba(63,185,80,0.1); }
    .badge-operational .badge-dot { background: var(--green); }
    .badge-degraded { color: var(--yellow); background: rgba(210,153,34,0.1); }
    .badge-degraded .badge-dot { background: var(--yellow); }
    .badge-partial { color: var(--orange); background: rgba(219,109,40,0.1); }
    .badge-partial .badge-dot { background: var(--orange); }
    .badge-major { color: var(--red); background: rgba(248,81,73,0.1); }
    .badge-major .badge-dot { background: var(--red); }
    .badge-loading { color: var(--text-muted); background: rgba(139,148,158,0.1); }
    .badge-loading .badge-dot { background: var(--text-muted); animation: pulse 1.5s infinite; }
    .badge-error { color: var(--text-muted); background: rgba(139,148,158,0.1); }
    .badge-error .badge-dot { background: var(--border); }

    /* ── Uptime bar ──────────────────────────────────────── */

    .uptime-bar {
      display: flex;
      gap: 2px;
      height: 30px;
      margin: 0.25rem 0 0.3rem;
    }

    .bar-segment {
      flex: 1;
      border-radius: 2px;
      transition: opacity 0.12s;
      position: relative;
      cursor: default;
    }

    .bar-segment:hover { opacity: 0.7; }

    .bar-operational { background-color: var(--green); }
    .bar-degraded { background-color: var(--yellow); }
    .bar-partial { background-color: var(--orange); }
    .bar-major { background-color: var(--red); }
    .bar-unknown { background-color: var(--bar-empty); }
    .bar-loading { background-color: var(--bar-empty); animation: pulse 1.5s infinite; }

    /* Tooltip via ::after */
    .bar-segment::after {
      content: attr(data-tip);
      display: none;
      position: absolute;
      bottom: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
      background: #1c2128;
      color: var(--text);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.68rem;
      white-space: nowrap;
      z-index: 20;
      pointer-events: none;
      border: 1px solid var(--border);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .bar-segment:hover::after { display: block; }

    .uptime-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.68rem;
      color: var(--text-muted);
    }

    .uptime-pct {
      font-weight: 500;
      color: var(--text-muted);
    }

    .uptime-pct.good { color: var(--green); }

    /* ── Proxy note ──────────────────────────────────────── */

    .proxy-note {
      padding: 0.75rem 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 1rem;
    }

    .proxy-note a { color: var(--blue); }

    .proxy-note code {
      background: rgba(255,255,255,0.06);
      padding: 0.1rem 0.35rem;
      border-radius: 4px;
      font-size: 0.75rem;
    }

    /* ── Animations ──────────────────────────────────────── */

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

    /* ── Responsive ──────────────────────────────────────── */

    @media (max-width: 700px) {
      body { padding: 1rem 0.75rem; }
      .header { flex-direction: column; align-items: flex-start; }
      .summary-card { min-width: 70px; padding: 0.6rem 0.75rem; }
      .summary-card .count { font-size: 1.3rem; }
      .service-row { padding: 0.7rem 0.85rem; }
      .uptime-bar { gap: 1px; height: 24px; }
      .bar-segment::after { font-size: 0.6rem; }
    }
  </style>
</head>
<body>

<div class="container">

  <div class="header">
    <h1>Happy Health &mdash; Dependency Status</h1>
    <div class="header-right">
      <span id="countdown">Refreshing in 60s</span>
      <button onclick="fetchAll()">Refresh now</button>
    </div>
  </div>

  <div class="overall-banner banner-loading" id="overall-banner">
    <span class="banner-dot"></span>
    <span id="overall-text">Checking system status&hellip;</span>
  </div>

  <div class="summary">
    <div class="summary-card">
      <div class="count count-operational" id="count-up">&ndash;</div>
      <div class="label">Operational</div>
    </div>
    <div class="summary-card">
      <div class="count count-degraded" id="count-degraded">&ndash;</div>
      <div class="label">Degraded</div>
    </div>
    <div class="summary-card">
      <div class="count count-outage" id="count-outage">&ndash;</div>
      <div class="label">Outage</div>
    </div>
    <div class="summary-card">
      <div class="count count-unknown" id="count-unknown">&ndash;</div>
      <div class="label">Unknown</div>
    </div>
  </div>

  <div id="services"></div>

  <div class="proxy-note" id="proxy-note" style="display:none">
    Some services block browser requests (CORS). Deploy a
    <a href="https://github.com/Zibri/cloudflare-cors-anywhere" target="_blank">Cloudflare Worker CORS proxy</a>
    and add <code>?proxy=https://your-worker.workers.dev</code> to enable all services.
  </div>

</div>

<script>
// ── Configuration ───────────────────────────────────────────────────────

const IS_LOCAL = location.hostname === "localhost" || location.hostname === "127.0.0.1";
const PROXY_URL = new URLSearchParams(location.search).get("proxy") || (IS_LOCAL ? "http://localhost:8787/proxy" : "");
const HISTORY_DAYS = 90;
const STORAGE_KEY = "hpy-uptime-history";
const REFRESH_INTERVAL = 60; // seconds

// ── Service definitions ─────────────────────────────────────────────────

const SERVICES = [
  // ── Cloud & Hosting ─────────────────────────────────────────────────
  sp("AWS", "Cloud & Hosting", "https://health.aws.amazon.com/health/status",
     null, "https://status.aws.amazon.com/rss/all.rss", false, "atom"),
  sp("Google Cloud", "Cloud & Hosting", "https://status.cloud.google.com",
     null, "https://status.cloud.google.com/feed.atom", true, "atom"),
  sp("Microsoft Azure", "Cloud & Hosting", "https://azure.status.microsoft/en-us/status",
     null, "https://azurestatuscdn.azureedge.net/en-us/status/feed/", true, "atom"),
  sp("Oracle Cloud", "Cloud & Hosting", "https://ocistatus.oraclecloud.com",
     null, "https://ocistatus.oraclecloud.com/api/v2/incident-summary.rss", false, "atom"),
  {
    name: "Cloudflare", category: "Cloud & Hosting",
    statusUrl: "https://www.cloudflarestatus.com",
    fetch: fetchStatuspageComponents("https://www.cloudflarestatus.com/api/v2/components.json", CLOUDFLARE_COMPONENT_IDS, "All core services operational"),
    incidentsUrl: "https://www.cloudflarestatus.com/api/v2/incidents.json",
  },
  sp("Vercel", "Cloud & Hosting", "https://www.vercel-status.com",
     "https://www.vercel-status.com"),

  // ── Authentication ──────────────────────────────────────────────────
  {
    name: "Stytch", category: "Authentication",
    statusUrl: "https://status.stytch.com",
    fetch: fetchInstatus("https://stytch.instatus.com/summary.json"),
  },

  // ── Healthcare ──────────────────────────────────────────────────────
  sp("Candid Health", "Healthcare", "https://status.joincandidhealth.com",
     "https://status.joincandidhealth.com"),
  sp("Healthie", "Healthcare", "https://status.gethealthie.com",
     "https://status.gethealthie.com"),
  // ── Payments ────────────────────────────────────────────────────────
  {
    name: "Stripe", category: "Payments",
    statusUrl: "https://status.stripe.com",
    fetch: fetchStripe("https://status.stripe.com/current"),
    needsProxy: true,
  },
  sp("Shopify", "Payments", "https://www.shopifystatus.com",
     "https://www.shopifystatus.com"),

  // ── Database ────────────────────────────────────────────────────────
  sp("Supabase", "Database", "https://status.supabase.com",
     "https://status.supabase.com"),

  // ── CMS ─────────────────────────────────────────────────────────────
  sp("Sanity", "CMS", "https://www.sanity-status.com",
     "https://www.sanity-status.com"),

  // ── Communications & Analytics ──────────────────────────────────────
  {
    name: "Twilio SMS (US)", category: "Communications",
    statusUrl: "https://status.twilio.com",
    fetch: fetchStatuspageComponents("https://status.twilio.com/api/v2/components.json", TWILIO_SMS_US_COMPONENT_IDS, "All SMS systems operational"),
    incidentsUrl: "https://status.twilio.com/api/v2/incidents.json",
  },
  {
    name: "Slack", category: "Communications",
    statusUrl: "https://slack-status.com",
    fetch: fetchSlack("https://slack-status.com/api/v2.0.0/current"),
  },
  sp("Customer.io", "Communications", "https://status.customerio.com",
     "https://status.customerio.com"),
  {
    name: "Segment", category: "Communications",
    statusUrl: "https://status.segment.com",
    fetch: fetchStatuspageComponents("https://status.segment.com/api/v2/components.json", SEGMENT_US_COMPONENT_IDS, "All US systems operational"),
    incidentsUrl: "https://status.segment.com/api/v2/incidents.json",
  },

  // ── Observability ───────────────────────────────────────────────────
  sp("Datadog", "Observability", "https://status.datadoghq.com",
     "https://status.datadoghq.com"),
  {
    name: "Sentry", category: "Observability",
    statusUrl: "https://status.sentry.io",
    fetch: fetchStatuspageComponents("https://status.sentry.io/api/v2/components.json", SENTRY_US_COMPONENT_IDS, "All US systems operational"),
    incidentsUrl: "https://status.sentry.io/api/v2/incidents.json",
  },
  {
    name: "Mixpanel", category: "Observability",
    statusUrl: "https://www.mixpanelstatus.com",
    fetch: fetchStatuspageComponents("https://www.mixpanelstatus.com/api/v2/components.json", MIXPANEL_US_COMPONENT_IDS, "All US systems operational"),
    incidentsUrl: "https://www.mixpanelstatus.com/api/v2/incidents.json",
  },

  // ── Workflow ────────────────────────────────────────────────────────
  sp("Inngest", "Workflow", "https://status.inngest.com",
     "https://status.inngest.com"),

  // ── Source Control ──────────────────────────────────────────────────
  sp("GitHub", "Source Control", "https://www.githubstatus.com",
     "https://www.githubstatus.com"),
  sp("Bitbucket", "Source Control", "https://bitbucket.status.atlassian.com",
     "https://bitbucket.status.atlassian.com"),
  {
    name: "GitLab", category: "Source Control",
    statusUrl: "https://status.gitlab.com",
    fetch: fetchAtomFeed("https://status.gitlab.com/pages/5b36dc6502d06804c08349f7/rss", false),
  },

  // ── Package Registries ──────────────────────────────────────────────
  sp("npm Registry", "Package Registries", "https://status.npmjs.org",
     "https://status.npmjs.org"),
  {
    name: "PyPI", category: "Package Registries",
    statusUrl: "https://status.python.org",
    fetch: fetchStatuspageComponents("https://status.python.org/api/v2/components.json", PYPI_COMPONENT_IDS, "All systems operational"),
    incidentsUrl: "https://status.python.org/api/v2/incidents.json",
  },

  // ── Mobile Platforms ────────────────────────────────────────────────
  {
    name: "Apple Developer", category: "Mobile Platforms",
    statusUrl: "https://developer.apple.com/system-status/",
    fetch: fetchApple("https://www.apple.com/support/systemstatus/data/developer/system_status_en_US.js"),
    needsProxy: true,
  },

  // ── Partner ─────────────────────────────────────────────────────────
  {
    name: "Eve", category: "Partner",
    statusUrl: "https://status.eve.co",
    fetch: fetchUptimeRobot("https://status.eve.co/api/getMonitorList/BQLq3SDoBo"),
  },
];

// Shorthand for Statuspage services (most common pattern)
function sp(name, category, statusUrl, statuspageBase, feedUrl, needsProxy, feedType) {
  const svc = { name, category, statusUrl };
  if (statuspageBase) {
    svc.fetch = fetchStatuspage(statuspageBase + "/api/v2/status.json");
    svc.incidentsUrl = statuspageBase + "/api/v2/incidents.json";
  } else if (feedUrl) {
    svc.fetch = fetchAtomFeed(feedUrl, !!needsProxy);
    svc.needsProxy = !!needsProxy;
  }
  return svc;
}

// ── State ───────────────────────────────────────────────────────────────

const serviceState = {};
let uptimeHistory = loadHistory();
let countdownSeconds = REFRESH_INTERVAL;
let countdownTimer = null;

// ── Category display order ──────────────────────────────────────────────

const CATEGORY_ORDER = [
  "Cloud & Hosting", "Authentication", "Healthcare", "Payments",
  "Database", "CMS", "Communications", "Observability", "Workflow",
  "Source Control", "Package Registries", "Mobile Platforms", "Partner",
];

// ── Fetcher factories ───────────────────────────────────────────────────

function proxyWrap(url, needsProxy) {
  if (needsProxy && PROXY_URL) {
    const sep = PROXY_URL.includes("?") ? "&" : "?";
    return PROXY_URL + sep + "url=" + encodeURIComponent(url);
  }
  return url;
}

function fetchStatuspage(apiUrl) {
  return async function () {
    const resp = await fetch(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const indicator = data.status?.indicator || "none";
    const description = data.status?.description || "Unknown";
    const levelMap = { none: "operational", minor: "degraded", major: "partial", critical: "major" };
    return { level: levelMap[indicator] || "operational", description };
  };
}

function fetchInstatus(apiUrl) {
  return async function () {
    const resp = await fetch(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const status = data.page?.status || "UNKNOWN";
    const levelMap = { UP: "operational", HASISSUES: "degraded", UNDERMAINTENANCE: "degraded" };
    return {
      level: levelMap[status] || "error",
      description: status === "UP" ? "All Systems Operational" : status,
    };
  };
}

// ── Component-scoped Statuspage fetcher (filters to specific component IDs) ──

function fetchStatuspageComponents(apiUrl, componentIds, okMessage) {
  const idSet = new Set(componentIds);
  return async function () {
    const resp = await fetch(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const components = (data.components || []).filter(c => idSet.has(c.id));
    const statusMap = { operational: 0, degraded_performance: 1, partial_outage: 2, major_outage: 3 };
    const levelMap = { operational: "operational", degraded_performance: "degraded", partial_outage: "partial", major_outage: "major" };
    let worstStatus = "operational";
    let worstSev = 0;
    const issues = [];
    for (const c of components) {
      const sev = statusMap[c.status] ?? 0;
      if (sev > worstSev) { worstSev = sev; worstStatus = c.status; }
      if (sev > 0) issues.push(c.name + ": " + c.status.replace(/_/g, " "));
    }
    return {
      level: levelMap[worstStatus] || "operational",
      description: issues.length > 0 ? issues.join("; ") : (okMessage || "All systems operational"),
    };
  };
}

// Twilio SMS (US) — only SMS/MMS components in North America
const TWILIO_SMS_US_COMPONENT_IDS = [
  "yvvy3vlp4djf", // SMS (Programmable Messaging)
  "d1j2nx64rpq3", // MMS (Programmable Messaging)
  "x3z86l06nvl7", // Programmable Messaging API
  "7d8w22hqrh6s", // SMS Long Code, North America
  "39mb8cmw8y2v", // SMS Short Code, North America
  "32f2bm54nkvv", // SMS Toll-Free, North America
  "8vdlvw3dsq8h", // MMS Long Code, North America
  "tvjwfvczkf46", // MMS Toll-Free, North America
];

// Cloudflare — core platform services only (excludes 450+ global edge PoPs)
const CLOUDFLARE_COMPONENT_IDS = [
  "5wnz34mhfhrk", // CDN/Cache
  "dp8ppfycqxcs", // Authoritative DNS
  "g4tb35rs9yw7", // API
  "3sq3s4d20ywk", // Dashboard
  "fbvx0hxhhdj0", // CDN Cache Purge
  "ts05t1p1j7r4", // DNS Firewall
  "4l9qztbt6rbj", // DNS Root Servers
  "w4k8yvhfb3vp", // Access
];

// Segment — US region only (excludes EU)
const SEGMENT_US_COMPONENT_IDS = [
  "g6z8h6bwf010", // Data Ingestion (Tracking) API (US)
  "c13tbpl4dm8m", // Web Interface (US)
  "klyl7cz2012x", // Analytics.js CDN (US)
  "7wv8256rdp62", // Streaming Destinations (US)
  "h32n3sb6hz33", // Cloud Sources (US)
  "ylfsvnn8hcs1", // Warehouse Destinations (US)
  "804tjyrkwnlw", // Libraries (US)
  "g6ncbp86zxm7", // Engage (US)
  "58j460c4vffk", // Data Processing Pipeline (US)
  "4snztn8n32qk", // Public API (US)
  "yk53kzcsw671", // Blobstore Destinations (US)
  "w392yz67sbxp", // Data Lakes (US)
  "1jxpx3ysdvj1", // Data Deletions (US)
  "hxjkwnmnyh7r", // Linked Audiences (US)
  "yk55rmb9rlym", // Reverse ETL (US)
  "zqj3vffxvytv", // Linked Events (US)
  "m0n5pwdch93f", // Journeys (US)
];

// Sentry — US ingestion + US alerting + global services (excludes EU)
const SENTRY_US_COMPONENT_IDS = [
  "khtl9dcky3lb", // Dashboard
  "qywmfv7jr0pd", // API
  "51yszynm4xyv", // US Error Ingestion
  "bdg4djkxjxmk", // US Transaction Ingestion
  "cycj4r32g25w", // US Attachment Ingestion
  "52t4t3ww2qcn", // US Profile Ingestion
  "zxkxxtspk64g", // US Replay Ingestion
  "qd7tzrk5q8xm", // US Span Ingestion
  "6f1r28lydc6h", // US Cron Monitoring
  "7wrqyj84ltw7", // Custom Metrics (beta)
  "bctv81yt9s6w", // US Errors Alerting
  "mbhk48shsbl8", // US Transactions Alerting
  "rcdlp8rvtf7t", // US Spans Alerting
  "fvsfbxc1mb16", // US Uptime Monitoring
];

// Mixpanel — US region + global services (excludes EU/India)
const MIXPANEL_US_COMPONENT_IDS = [
  "45yb5qck0sw5", // Application Availability (US)
  "cq5ttq9czyjh", // Ingestion API Availability (US)
  "7cdmvbkr0dyq", // JavaScript Library CDN
  "tjt23lh5r46g", // Data Export
  "v1kc88rj0qmw", // Warehouse Connectors
];

// PyPI — core service only (excludes 80+ Fastly CDN edge nodes)
const PYPI_COMPONENT_IDS = [
  "06hwjcnhlz03", // pypi.org - General
  "xt7f24hjvspn", // pypi.org - CDN
  "yjlyv2k3zz3p", // pypi.org - Backends
  "frjs3hvgp2bk", // files.pythonhosted.org - Files
  "p2b1wmgvmwln", // files.pythonhosted.org - Redirects
  "nj4jx0hljzvl", // files.pythonhosted.org - Redirects Backends
  "5k8sx11bnccq", // pypi.org - Email
];

function fetchSlack(apiUrl) {
  return async function () {
    const resp = await fetch(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    if (data.status === "ok" || (data.active_incidents || []).length === 0) {
      return { level: "operational", description: "All Systems Operational" };
    }
    const inc = data.active_incidents[0];
    const level = inc.type === "outage" ? "major" : "degraded";
    return { level, description: inc.title || "Active incident" };
  };
}

function fetchUptimeRobot(apiUrl) {
  return async function () {
    const resp = await fetch(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const counts = data.statistics?.counts || {};
    if (counts.down > 0) {
      return { level: "major", description: counts.down + " of " + counts.total + " monitors down" };
    }
    return { level: "operational", description: "All monitors up" };
  };
}

function fetchStripe(apiUrl) {
  return async function () {
    const url = proxyWrap(apiUrl, true);
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const levelMap = { up: "operational", degraded: "degraded", down: "major" };
    return {
      level: levelMap[data.largestatus] || "error",
      description: data.message || "Unknown",
    };
  };
}

function fetchAtomFeed(feedUrl, needsProxy) {
  return async function () {
    const url = proxyWrap(feedUrl, needsProxy);
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const text = await resp.text();
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    const parseError = xml.querySelector("parsererror");

    if (!parseError) {
      const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
      const entries = xml.querySelectorAll("entry, item");
      const recentIncidents = [];

      for (const entry of entries) {
        const updated = entry.querySelector("updated, pubDate");
        if (updated) {
          const date = new Date(updated.textContent.trim());
          if (date.getTime() > oneDayAgo) {
            const title = entry.querySelector("title")?.textContent?.trim() || "";
            recentIncidents.push(title);
          }
        }
      }

      if (recentIncidents.length === 0) {
        return { level: "operational", description: "No recent incidents" };
      }

      const latest = recentIncidents[0];
      return { level: classifyIncidentTitle(latest), description: latest };
    }

    // Fallback: parse as HTML
    const html = parser.parseFromString(text, "text/html");
    const bodyText = html.body?.textContent || "";
    if (/all systems operational|no issues/i.test(bodyText)) {
      return { level: "operational", description: "All Systems Operational" };
    }
    if (/operational/i.test(bodyText)) {
      return { level: "operational", description: "Operational" };
    }
    return { level: "error", description: "Could not parse status" };
  };
}

function fetchApple(apiUrl) {
  return async function () {
    const url = proxyWrap(apiUrl, true);
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const text = await resp.text();
    const match = text.match(/jsonCallback\((.+)\)/s);
    if (!match) throw new Error("Could not parse JSONP");
    const data = JSON.parse(match[1]);
    const services = data.services || [];
    const issues = services.filter(
      (s) => s.events?.length > 0 && s.events.some((e) => e.statusType !== "resolved")
    );
    if (issues.length === 0) {
      return { level: "operational", description: "All Developer Services Operational" };
    }
    return { level: "degraded", description: issues.length + " service(s) with active events" };
  };
}



// ── Helpers ──────────────────────────────────────────────────────────────

function classifyIncidentTitle(title) {
  const t = title.toLowerCase();
  if (/resolved|completed|scheduled/i.test(t)) return "operational";
  if (/major|critical|outage/i.test(t)) return "major";
  if (/partial/i.test(t)) return "partial";
  if (/degraded|elevated|minor|investigating|monitoring/i.test(t)) return "degraded";
  return "degraded";
}

function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

function escapeHtml(s) {
  const d = document.createElement("div");
  d.textContent = s;
  return d.innerHTML;
}

function getDayKey(date) {
  return date.toISOString().split("T")[0];
}

function getLast90Days() {
  const days = [];
  for (let i = HISTORY_DAYS - 1; i >= 0; i--) {
    const d = new Date();
    d.setDate(d.getDate() - i);
    days.push(getDayKey(d));
  }
  return days;
}

function formatDate(dateStr) {
  const d = new Date(dateStr + "T12:00:00");
  return d.toLocaleDateString("en-US", { month: "short", day: "numeric" });
}

// ── History (localStorage) ──────────────────────────────────────────────

function loadHistory() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch { return {}; }
}

function saveHistory() {
  try {
    // Prune entries older than 120 days to keep storage lean
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - 120);
    const cutoffStr = getDayKey(cutoff);
    for (const svc of Object.keys(uptimeHistory)) {
      for (const day of Object.keys(uptimeHistory[svc])) {
        if (day < cutoffStr) delete uptimeHistory[svc][day];
      }
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(uptimeHistory));
  } catch { /* storage full or unavailable */ }
}

function recordStatus(serviceName, level) {
  const today = getDayKey(new Date());
  if (!uptimeHistory[serviceName]) uptimeHistory[serviceName] = {};

  const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3, error: -1, loading: -1 };
  const current = uptimeHistory[serviceName][today];
  const currentSev = SEVERITY[current] ?? -1;
  const newSev = SEVERITY[level] ?? -1;

  // Only upgrade severity for the day (don't downgrade)
  if (newSev > currentSev) {
    uptimeHistory[serviceName][today] = level;
  } else if (currentSev < 0 && newSev >= 0) {
    uptimeHistory[serviceName][today] = level;
  }
}

// ── Rendering ───────────────────────────────────────────────────────────

function render() {
  const container = document.getElementById("services");
  container.innerHTML = "";

  // Group services by category
  const groups = {};
  for (const svc of SERVICES) {
    if (!groups[svc.category]) groups[svc.category] = [];
    groups[svc.category].push(svc);
  }

  // Render in category order
  for (const cat of CATEGORY_ORDER) {
    const svcs = groups[cat];
    if (!svcs) continue;

    const group = document.createElement("div");
    group.className = "service-group";
    group.innerHTML = '<div class="group-title">' + escapeHtml(cat) + "</div>";

    const card = document.createElement("div");
    card.className = "group-card";

    for (const svc of svcs) {
      card.appendChild(renderServiceRow(svc));
    }

    group.appendChild(card);
    container.appendChild(group);
  }

  updateSummary();
  updateBanner();
}

function renderServiceRow(svc) {
  const s = serviceState[svc.name] || { level: "loading", description: "Checking..." };
  const row = document.createElement("div");
  row.className = "service-row";

  const badgeClass = "badge-" + (s.level || "error");
  const label = capitalize(s.level === "error" ? "unknown" : (s.level || "unknown"));

  // Header: name + badge
  let headerHtml = '<div class="service-header">';
  headerHtml += '<span class="service-name"><a href="' + svc.statusUrl + '" target="_blank" rel="noopener">' + escapeHtml(svc.name) + "</a></span>";
  headerHtml += '<span class="status-badge ' + badgeClass + '"><span class="badge-dot"></span>' + label + "</span>";
  headerHtml += "</div>";

  // Uptime bar
  const days = getLast90Days();
  const history = uptimeHistory[svc.name] || {};
  let barHtml = '<div class="uptime-bar">';
  let totalDays = 0, opDays = 0;

  for (const day of days) {
    const dayStatus = history[day];
    const barClass = dayStatus ? "bar-" + dayStatus : (s.level === "loading" ? "bar-loading" : "bar-unknown");
    const tipStatus = dayStatus ? capitalize(dayStatus) : "No data";
    const tip = formatDate(day) + " — " + tipStatus;
    barHtml += '<div class="bar-segment ' + barClass + '" data-tip="' + tip + '"></div>';

    if (dayStatus && dayStatus !== "error") {
      totalDays++;
      if (dayStatus === "operational") opDays++;
    }
  }
  barHtml += "</div>";

  // Footer: date range + uptime %
  const pct = totalDays > 0 ? ((opDays / totalDays) * 100).toFixed(2) : null;
  const pctClass = pct !== null && parseFloat(pct) >= 99 ? "good" : "";
  const pctText = pct !== null ? pct + "% uptime" : "";
  let footerHtml = '<div class="uptime-footer">';
  footerHtml += "<span>90 days ago</span>";
  footerHtml += '<span class="uptime-pct ' + pctClass + '">' + pctText + "</span>";
  footerHtml += "<span>Today</span>";
  footerHtml += "</div>";

  row.innerHTML = headerHtml + barHtml + footerHtml;
  return row;
}

function updateSummary() {
  let up = 0, degraded = 0, outage = 0, unknown = 0;
  for (const svc of SERVICES) {
    const s = serviceState[svc.name];
    if (!s || s.level === "loading" || s.level === "error") { unknown++; continue; }
    if (s.level === "operational") up++;
    else if (s.level === "degraded" || s.level === "partial") degraded++;
    else if (s.level === "major") outage++;
    else unknown++;
  }
  document.getElementById("count-up").textContent = up;
  document.getElementById("count-degraded").textContent = degraded;
  document.getElementById("count-outage").textContent = outage;
  document.getElementById("count-unknown").textContent = unknown;
}

function updateBanner() {
  const banner = document.getElementById("overall-banner");
  const text = document.getElementById("overall-text");
  const states = SERVICES.map((s) => serviceState[s.name]?.level).filter(Boolean);

  if (states.length === 0 || states.every((l) => l === "loading")) {
    banner.className = "overall-banner banner-loading";
    text.textContent = "Checking system status\u2026";
    return;
  }

  const hasOutage = states.includes("major");
  const hasDegraded = states.includes("degraded") || states.includes("partial");

  if (hasOutage) {
    banner.className = "overall-banner banner-outage";
    text.textContent = "Major outage detected on one or more services";
  } else if (hasDegraded) {
    banner.className = "overall-banner banner-degraded";
    text.textContent = "Some systems are experiencing issues";
  } else {
    banner.className = "overall-banner banner-operational";
    text.textContent = "All systems operational";
  }
}

// ── Main loop ───────────────────────────────────────────────────────────

async function fetchAll() {
  countdownSeconds = REFRESH_INTERVAL;

  // Show proxy note if needed
  const needsProxy = SERVICES.some((s) => s.needsProxy);
  document.getElementById("proxy-note").style.display =
    needsProxy && !PROXY_URL ? "block" : "none";

  // Initialize loading state
  for (const svc of SERVICES) {
    if (!serviceState[svc.name]) {
      serviceState[svc.name] = { level: "loading", description: "Checking...", checkedAt: null };
    }
  }
  render();

  // Fetch all current statuses
  const promises = SERVICES.map(async (svc) => {
    if (svc.needsProxy && !PROXY_URL) {
      serviceState[svc.name] = { level: "error", description: "Needs CORS proxy", checkedAt: Date.now() };
      render();
      return;
    }
    try {
      const result = await svc.fetch();
      serviceState[svc.name] = { ...result, checkedAt: Date.now() };
      recordStatus(svc.name, result.level);
    } catch (e) {
      serviceState[svc.name] = { level: "error", description: "Failed: " + e.message, checkedAt: Date.now() };
    }
    render();
  });

  await Promise.allSettled(promises);
  saveHistory();
  render();

  // Backfill 90-day history from Statuspage incident APIs (non-blocking)
  populateIncidentHistory();
}

async function populateIncidentHistory() {
  const statuspageServices = SERVICES.filter((s) => s.incidentsUrl);
  if (statuspageServices.length === 0) return;

  const days = getLast90Days();
  const ninetyDaysAgo = Date.now() - HISTORY_DAYS * 24 * 60 * 60 * 1000;

  const promises = statuspageServices.map(async (svc) => {
    try {
      const resp = await fetch(svc.incidentsUrl, { cache: "no-store" });
      if (!resp.ok) return;
      const data = await resp.json();

      if (!uptimeHistory[svc.name]) uptimeHistory[svc.name] = {};

      // Mark days with incidents
      for (const inc of data.incidents || []) {
        const dateStr = inc.created_at?.split("T")[0];
        if (!dateStr) continue;
        if (new Date(dateStr + "T00:00:00").getTime() < ninetyDaysAgo) continue;

        const impactMap = { none: null, minor: "degraded", major: "partial", critical: "major" };
        const level = impactMap[inc.impact];
        if (!level) continue;

        const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
        const existing = uptimeHistory[svc.name][dateStr];
        if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
          uptimeHistory[svc.name][dateStr] = level;
        }
      }

      // Fill in operational for days with no incidents
      for (const day of days) {
        if (!uptimeHistory[svc.name][day]) {
          uptimeHistory[svc.name][day] = "operational";
        }
      }
    } catch { /* silently ignore history fetch failures */ }
  });

  await Promise.allSettled(promises);
  saveHistory();
  render();
}

function startCountdown() {
  if (countdownTimer) clearInterval(countdownTimer);
  countdownSeconds = REFRESH_INTERVAL;
  countdownTimer = setInterval(() => {
    countdownSeconds--;
    document.getElementById("countdown").textContent = "Refreshing in " + countdownSeconds + "s";
    if (countdownSeconds <= 0) fetchAll();
  }, 1000);
}

// ── Init ────────────────────────────────────────────────────────────────

fetchAll();
startCountdown();
</script>
</body>
</html>

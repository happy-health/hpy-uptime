<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Happy Health — Internal Status</title>
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --surface-hover: #1c2128;
      --border: #30363d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --green: #3fb950;
      --yellow: #d29922;
      --orange: #db6d28;
      --red: #f85149;
      --blue: #58a6ff;
      --purple: #bc8cff;
      --bar-empty: #21262d;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 0;
    }

    .container { max-width: 1060px; margin: 0 auto; padding: 1.5rem; }

    /* ── Top banner bar (matches dashboard.happy-health.net) ── */

    .top-bar {
      background: #1e293b;
      padding: 0.75rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.75rem;
      position: sticky;
      top: 0;
      z-index: 50;
    }

    .top-bar-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .top-bar h1 {
      font-size: 1rem;
      font-weight: 600;
      color: #f1f5f9;
      margin: 0;
    }

    .top-bar-right {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.8rem;
    }

    .pill-btn {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #cbd5e1;
      padding: 0.4rem 1rem;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: background 0.15s, color 0.15s;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .pill-btn:hover { background: rgba(255,255,255,0.15); color: #f1f5f9; }

    .pill-btn-primary {
      background: rgba(99,102,241,0.25);
      border-color: rgba(99,102,241,0.3);
      color: #a5b4fc;
    }

    .pill-btn-primary:hover {
      background: rgba(99,102,241,0.35);
      color: #c7d2fe;
    }

    .top-bar .countdown {
      color: #64748b;
      font-size: 0.75rem;
    }

    .top-bar .user-email {
      color: #94a3b8;
      font-size: 0.75rem;
    }

    .badge-internal {
      font-size: 0.6rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(99,102,241,0.2);
      color: #a5b4fc;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
    }

    /* ── Login gate ──────────────────────────────────────── */

    .login-gate {
      max-width: 400px;
      margin: 10vh auto;
      text-align: center;
    }

    .login-gate h2 {
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }

    .login-gate p {
      color: var(--text-muted);
      font-size: 0.9rem;
      margin-bottom: 2rem;
    }

    #stytch-login {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      min-height: 200px;
    }

    .api-key-form {
      margin-top: 1.5rem;
      text-align: left;
    }

    .api-key-form label {
      display: block;
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-bottom: 0.4rem;
    }

    .api-key-form .input-row {
      display: flex;
      gap: 0.5rem;
    }

    .api-key-form input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.55rem 0.75rem;
      border-radius: 8px;
      font-size: 0.85rem;
      font-family: inherit;
      outline: none;
      transition: border-color 0.15s;
    }

    .api-key-form input:focus { border-color: var(--blue); }

    .api-key-form input::placeholder { color: #484f58; }

    .api-key-form .unlock-btn {
      background: #1e293b;
      border: 1px solid rgba(255,255,255,0.12);
      color: #cbd5e1;
      padding: 0.55rem 1.25rem;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      white-space: nowrap;
      transition: background 0.15s;
    }

    .api-key-form .unlock-btn:hover { background: #334155; }

    .api-key-form .url-input {
      margin-bottom: 0.5rem;
    }

    .api-key-form .url-input input {
      width: 100%;
    }

    .api-key-divider {
      margin: 1.5rem 0;
      text-align: center;
      font-size: 0.75rem;
      color: #484f58;
      position: relative;
    }

    .api-key-divider::before,
    .api-key-divider::after {
      content: "";
      position: absolute;
      top: 50%;
      width: 40%;
      height: 1px;
      background: var(--border);
    }

    .api-key-divider::before { left: 0; }
    .api-key-divider::after { right: 0; }

    /* ── Overall banner ──────────────────────────────────── */

    .overall-banner {
      padding: 1rem 1.25rem;
      border-radius: 8px;
      margin-bottom: 1.25rem;
      font-weight: 600;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      border: 1px solid;
    }

    .overall-banner .banner-dot {
      width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0;
    }

    .banner-operational { background: rgba(63,185,80,0.08); border-color: rgba(63,185,80,0.3); color: var(--green); }
    .banner-operational .banner-dot { background: var(--green); }
    .banner-degraded { background: rgba(210,153,34,0.08); border-color: rgba(210,153,34,0.3); color: var(--yellow); }
    .banner-degraded .banner-dot { background: var(--yellow); }
    .banner-outage { background: rgba(248,81,73,0.08); border-color: rgba(248,81,73,0.3); color: var(--red); }
    .banner-outage .banner-dot { background: var(--red); }
    .banner-loading { background: var(--surface); border-color: var(--border); color: var(--text-muted); }
    .banner-loading .banner-dot { background: var(--text-muted); animation: pulse 1.5s infinite; }

    /* ── Mismatch alerts ─────────────────────────────────── */

    .mismatch-alerts { margin-bottom: 1.25rem; }

    .mismatch-alert {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
      display: flex;
      align-items: flex-start;
      gap: 0.6rem;
      border: 1px solid;
    }

    .mismatch-alert .alert-icon {
      font-size: 1rem;
      line-height: 1.3;
      flex-shrink: 0;
    }

    .mismatch-alert .alert-text strong {
      display: block;
      margin-bottom: 0.15rem;
    }

    .mismatch-alert .alert-detail {
      color: var(--text-muted);
      font-size: 0.78rem;
    }

    .mismatch-ours-down {
      background: rgba(248,81,73,0.06);
      border-color: rgba(248,81,73,0.25);
      color: var(--red);
    }

    .mismatch-vendor-down {
      background: rgba(210,153,34,0.06);
      border-color: rgba(210,153,34,0.25);
      color: var(--yellow);
    }

    .mismatch-both-down {
      background: rgba(219,109,40,0.06);
      border-color: rgba(219,109,40,0.25);
      color: var(--orange);
    }

    /* ── Summary cards ───────────────────────────────────── */

    .summary {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.75rem;
      flex-wrap: wrap;
    }

    .summary-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.85rem 1.25rem;
      flex: 1;
      min-width: 100px;
      text-align: center;
    }

    .summary-card { cursor: pointer; transition: border-color 0.15s, background 0.15s; }
    .summary-card:hover { background: var(--surface-hover); }
    .summary-card.active { border-color: var(--blue); background: rgba(88,166,255,0.06); }
    .summary-card .count { font-size: 1.75rem; font-weight: 700; line-height: 1.2; }
    .summary-card .label { font-size: 0.72rem; color: var(--text-muted); margin-top: 0.15rem; }

    .count-operational { color: var(--green); }
    .count-degraded { color: var(--yellow); }
    .count-outage { color: var(--red); }
    .count-unknown { color: var(--text-muted); }
    .count-mismatch { color: var(--purple); }

    /* ── Category groups ─────────────────────────────────── */

    .service-group { margin-bottom: 1.75rem; }

    .group-title {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      padding-left: 0.25rem;
    }

    .group-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    /* ── Service row ─────────────────────────────────────── */

    .service-row {
      padding: 0.85rem 1.15rem;
      border-bottom: 1px solid var(--border);
      transition: background 0.1s;
    }

    .service-row:last-child { border-bottom: none; }
    .service-row:hover { background: var(--surface-hover); }

    .service-row.has-mismatch {
      border-left: 3px solid var(--purple);
    }

    .service-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.2rem;
    }

    .service-name {
      font-weight: 500;
      font-size: 0.9rem;
    }

    .service-name a {
      color: var(--text);
      text-decoration: none;
      transition: color 0.15s;
    }

    .service-name a:hover { color: var(--blue); }

    .status-badges {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .status-badge {
      font-size: 0.72rem;
      font-weight: 500;
      padding: 0.15rem 0.55rem;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }

    .status-badge .badge-dot {
      width: 7px; height: 7px; border-radius: 50%;
    }

    .badge-label {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-right: 0.15rem;
    }

    .badge-operational { color: var(--green); background: rgba(63,185,80,0.1); }
    .badge-operational .badge-dot { background: var(--green); }
    .badge-degraded { color: var(--yellow); background: rgba(210,153,34,0.1); }
    .badge-degraded .badge-dot { background: var(--yellow); }
    .badge-partial { color: var(--orange); background: rgba(219,109,40,0.1); }
    .badge-partial .badge-dot { background: var(--orange); }
    .badge-major { color: var(--red); background: rgba(248,81,73,0.1); }
    .badge-major .badge-dot { background: var(--red); }
    .badge-unknown { color: var(--text-muted); background: rgba(139,148,158,0.1); }
    .badge-unknown .badge-dot { background: var(--text-muted); }
    .badge-loading { color: var(--text-muted); background: rgba(139,148,158,0.1); }
    .badge-loading .badge-dot { background: var(--text-muted); animation: pulse 1.5s infinite; }
    .badge-error { color: var(--text-muted); background: rgba(139,148,158,0.1); }
    .badge-error .badge-dot { background: var(--border); }

    .badge-unmonitored { color: var(--text-muted); background: rgba(139,148,158,0.08); font-style: italic; }
    .badge-unmonitored .badge-dot { background: var(--text-muted); opacity: 0.5; }

    /* ── Dual uptime bars ─────────────────────────────────── */

    .bar-pair { margin-top: 0.35rem; }

    .bar-label {
      font-size: 0.62rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--text-muted);
      margin-bottom: 2px;
    }

    .bar-label.global-label { color: var(--blue); opacity: 0.7; }
    .bar-label.ours-label { color: var(--purple); opacity: 0.7; }

    .uptime-bar {
      display: flex;
      gap: 2px;
      height: 20px;
      margin-bottom: 0.2rem;
    }

    .uptime-bar.single { height: 28px; }

    .bar-segment {
      flex: 1;
      border-radius: 2px;
      transition: opacity 0.12s;
      position: relative;
      cursor: default;
    }

    .bar-segment:hover { opacity: 0.7; }

    .bar-operational { background-color: var(--green); }
    .bar-degraded { background-color: var(--yellow); }
    .bar-partial { background-color: var(--orange); }
    .bar-major { background-color: var(--red); }
    .bar-unknown { background-color: var(--bar-empty); }
    .bar-loading { background-color: var(--bar-empty); animation: pulse 1.5s infinite; }

    .bar-segment::after {
      content: attr(data-tip);
      display: none;
      position: absolute;
      bottom: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
      background: #1c2128;
      color: var(--text);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.68rem;
      white-space: nowrap;
      z-index: 20;
      pointer-events: none;
      border: 1px solid var(--border);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .bar-segment:hover::after { display: block; }

    /* Anchor edge tooltips to prevent off-screen clipping */
    .bar-segment:nth-child(-n+3)::after { left: 0; transform: none; }
    .bar-segment:nth-last-child(-n+3)::after { left: auto; right: 0; transform: none; }

    .uptime-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.68rem;
      color: var(--text-muted);
    }

    .uptime-pct { font-weight: 500; }
    .uptime-pct.good { color: var(--green); }

    .mismatch-inline {
      font-size: 0.72rem;
      color: var(--purple);
      margin-top: 0.25rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    /* ── Footer ──────────────────────────────────────────── */

    .page-footer {
      margin-top: 2rem;
      padding: 1rem 0;
      text-align: center;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .page-footer a { color: var(--blue); text-decoration: none; }
    .page-footer a:hover { text-decoration: underline; }

    /* ── Legend ────────────────────────────────────────────── */

    .legend {
      display: flex;
      gap: 1.5rem;
      margin-bottom: 1.25rem;
      font-size: 0.72rem;
      color: var(--text-muted);
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .legend-swatch {
      width: 14px;
      height: 10px;
      border-radius: 2px;
    }

    /* ── Environment toggle ─────────────────────────────── */

    .env-toggle {
      display: flex;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      overflow: hidden;
      gap: 0;
    }

    .env-toggle-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 0.45rem 1rem;
      font-size: 0.82rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      font-family: inherit;
    }

    .env-toggle-btn:hover { background: rgba(255,255,255,0.06); color: var(--text); }

    .env-toggle-btn.active {
      background: rgba(99,102,241,0.25);
      color: #a5b4fc;
    }

    .env-toggle-sm .env-toggle-btn {
      padding: 0.3rem 0.75rem;
      font-size: 0.75rem;
    }

    .custom-url-link {
      display: inline-block;
      margin-top: 0.5rem;
      font-size: 0.72rem;
      color: var(--text-muted);
      text-decoration: none;
      cursor: pointer;
    }

    .custom-url-link:hover { color: var(--blue); }

    .custom-url-row {
      margin-bottom: 0.5rem;
    }

    .custom-url-row label {
      display: block;
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-bottom: 0.4rem;
    }

    .custom-url-row input {
      width: 100%;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.55rem 0.75rem;
      border-radius: 8px;
      font-size: 0.85rem;
      font-family: inherit;
      outline: none;
      transition: border-color 0.15s;
    }

    .custom-url-row input:focus { border-color: var(--blue); }

    /* ── Expand / collapse ──────────────────────────────── */

    .service-row.expandable { cursor: pointer; }
    .service-row.expandable:hover { background: rgba(255,255,255,0.03); }

    .expand-icon {
      display: inline-block;
      font-size: 0.6rem;
      margin-right: 0.4rem;
      transition: transform 0.2s ease;
      color: var(--text-muted);
    }

    .expand-icon.expanded { transform: rotate(90deg); }

    .bar-detail {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.25s ease, opacity 0.2s ease;
      opacity: 0;
    }

    .bar-detail.open {
      max-height: 200px;
      opacity: 1;
    }

    /* ── Local dev / data source badges ────────────────── */

    .badge-local-dev {
      font-size: 0.6rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(219,109,40,0.2);
      color: #db6d28;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
    }

    .badge-data-source {
      font-size: 0.6rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      cursor: help;
    }

    .badge-mock {
      background: rgba(210,153,34,0.2);
      color: var(--yellow);
    }

    .badge-live {
      background: rgba(63,185,80,0.15);
      color: var(--green);
    }

    .internal-error-bar {
      padding: 0.6rem 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      font-size: 0.82rem;
      background: rgba(248,81,73,0.08);
      border: 1px solid rgba(248,81,73,0.25);
      color: var(--red);
      display: none;
    }

    /* ── Team filter bar ──────────────────────────────────── */

    .team-filter-bar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.25rem;
      flex-wrap: wrap;
    }

    .team-pill {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--text-muted);
      padding: 0.4rem 0.9rem;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: background 0.15s, color 0.15s, border-color 0.15s;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-family: inherit;
    }

    .team-pill:hover { background: rgba(255,255,255,0.1); color: var(--text); }

    .team-pill.active {
      background: rgba(99,102,241,0.2);
      border-color: rgba(99,102,241,0.35);
      color: #c7d2fe;
    }

    .team-pill .team-dot {
      width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
    }

    .team-dot-operational { background: var(--green); }
    .team-dot-degraded { background: var(--yellow); }
    .team-dot-major { background: var(--red); }
    .team-dot-unknown { background: var(--text-muted); opacity: 0.5; }

    /* ── Team summary banner ─────────────────────────────── */

    .team-summary-banner {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1.25rem;
      margin-bottom: 1.25rem;
      font-size: 0.85rem;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .team-summary-banner .team-summary-label {
      font-weight: 600;
    }

    .team-summary-banner .team-summary-detail {
      color: var(--text-muted);
    }

    .team-summary-counts {
      display: flex;
      gap: 0.75rem;
      margin-left: auto;
      font-size: 0.78rem;
    }

    .team-summary-counts span { display: inline-flex; align-items: center; gap: 0.25rem; }

    /* ── Active issues panel ──────────────────────────── */

    .active-issues {
      margin-bottom: 1.25rem;
      border: 1px solid rgba(248,81,73,0.25);
      border-radius: 8px;
      overflow: hidden;
    }

    .active-issues-header {
      background: rgba(248,81,73,0.06);
      padding: 0.6rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.78rem;
      font-weight: 600;
      color: var(--red);
      border-bottom: 1px solid rgba(248,81,73,0.15);
      cursor: pointer;
    }

    .active-issues-header .pulse-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--red);
      animation: pulse 1.5s infinite;
      flex-shrink: 0;
    }

    .active-issues-header .issue-count {
      margin-left: auto;
      font-weight: 400;
      color: var(--text-muted);
      font-size: 0.72rem;
    }

    .active-issues.degraded-only {
      border-color: rgba(210,153,34,0.25);
    }

    .active-issues.degraded-only .active-issues-header {
      background: rgba(210,153,34,0.06);
      color: var(--yellow);
      border-bottom-color: rgba(210,153,34,0.15);
    }

    .active-issues.degraded-only .pulse-dot {
      background: var(--yellow);
    }

    .active-issue-row {
      padding: 0.6rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      border-bottom: 1px solid var(--border);
      font-size: 0.85rem;
      background: var(--surface);
    }

    .active-issue-row:last-child { border-bottom: none; }

    .active-issue-row .issue-dot {
      width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
    }

    .active-issue-row .issue-name {
      font-weight: 500;
      min-width: 120px;
    }

    .active-issue-row .issue-detail {
      color: var(--text-muted);
      font-size: 0.78rem;
      flex: 1;
    }

    .active-issue-row .issue-badges {
      display: flex;
      gap: 0.4rem;
      flex-shrink: 0;
    }

    /* ── Active filter indicator ────────────────────────── */

    .filter-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .filter-indicator .filter-label {
      background: rgba(88,166,255,0.1);
      border: 1px solid rgba(88,166,255,0.25);
      color: var(--blue);
      padding: 0.25rem 0.7rem;
      border-radius: 14px;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-weight: 500;
    }

    .filter-indicator .filter-clear {
      cursor: pointer;
      font-size: 0.9rem;
      opacity: 0.7;
      transition: opacity 0.15s;
      line-height: 1;
    }

    .filter-indicator .filter-clear:hover { opacity: 1; }

    /* ── Empty state ───────────────────────────────────── */

    .empty-state {
      text-align: center;
      padding: 3rem 1rem;
      color: var(--text-muted);
    }

    .empty-state .empty-icon { font-size: 1.8rem; margin-bottom: 0.5rem; opacity: 0.5; }
    .empty-state .empty-text { font-size: 0.9rem; }

    /* ── Last updated timestamp ────────────────────────── */

    .last-updated {
      font-size: 0.72rem;
      color: var(--text-muted);
      text-align: right;
      margin-bottom: 0.5rem;
      opacity: 0.7;
    }

    /* ── Animations ──────────────────────────────────────── */

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

    /* ── Responsive ──────────────────────────────────────── */

    @media (max-width: 700px) {
      body { padding: 1rem 0.75rem; }
      .header { flex-direction: column; align-items: flex-start; }
      .summary-card { min-width: 60px; padding: 0.6rem 0.75rem; }
      .summary-card .count { font-size: 1.3rem; }
      .service-row { padding: 0.7rem 0.85rem; }
      .uptime-bar { gap: 1px; height: 16px; }
      .uptime-bar.single { height: 22px; }
      .status-badges { flex-wrap: wrap; }
      .team-filter-bar { gap: 0.35rem; }
      .team-pill { padding: 0.35rem 0.7rem; font-size: 0.72rem; }
      .team-summary-banner { flex-direction: column; align-items: flex-start; gap: 0.3rem; }
      .team-summary-counts { margin-left: 0; }
      .top-bar { flex-direction: column; align-items: flex-start; padding: 0.6rem 1rem; }
      .top-bar-right { width: 100%; flex-wrap: wrap; justify-content: flex-start; gap: 0.4rem; }
      .summary { gap: 0.4rem; }
    }
  </style>
</head>
<body>

<!-- ── Top bar (always visible, matches dashboard.happy-health.net) ── -->

<div class="top-bar">
  <div class="top-bar-left">
    <h1>Happy Health &mdash; Status</h1>
    <span class="badge-internal">Global + Internal</span>
    <span class="badge-local-dev" id="local-dev-badge" style="display:none">Local Dev</span>
    <span class="badge-data-source" id="data-source-badge" style="display:none"></span>
    <div class="env-toggle env-toggle-sm" id="topbar-env-toggle" style="display:none">
      <button class="env-toggle-btn active" data-env="prod" onclick="switchEnv('prod')">Prod</button>
      <button class="env-toggle-btn" data-env="staging" onclick="switchEnv('staging')">Staging</button>
    </div>
  </div>
  <div class="top-bar-right" id="top-bar-actions" style="display:none">
    <span class="user-email" id="user-email"></span>
    <span class="countdown" id="countdown">Refreshing in 60s</span>
    <button class="pill-btn" id="expand-all-btn" onclick="toggleExpandAll()" style="display:none">Expand All</button>
    <button class="pill-btn" onclick="refreshAll()">Reload</button>
    <button class="pill-btn pill-btn-primary" onclick="logout()">Sign out</button>
  </div>
</div>

<!-- ── Login gate (shown when not authenticated) ──────────── -->

<div class="login-gate" id="login-gate">
  <h2>Internal Status Dashboard</h2>
  <p>Sign in with your Happy Health account to view global + internal system health side-by-side.</p>

  <div class="api-key-form">
    <label style="margin-bottom:0.5rem">Environment</label>
    <div class="env-toggle" id="login-env-toggle">
      <button class="env-toggle-btn active" data-env="prod" onclick="setLoginEnv('prod')">Production</button>
      <button class="env-toggle-btn" data-env="staging" onclick="setLoginEnv('staging')">Staging</button>
    </div>
    <div class="custom-url-row" id="custom-url-row" style="display:none">
      <label for="input-api-url">Custom API URL</label>
      <input type="text" id="input-api-url" placeholder="https://your-api.example.com" />
    </div>
    <a href="#" class="custom-url-link" id="custom-url-link" onclick="toggleCustomUrl(event)">Use custom URL</a>
    <label for="input-api-key" style="margin-top:0.75rem">API Key</label>
    <div class="input-row">
      <input type="password" id="input-api-key" placeholder="Enter API key to unlock" />
      <button class="unlock-btn" onclick="unlockWithApiKey()">Unlock</button>
    </div>
  </div>

  <div class="api-key-divider">or sign in with Stytch</div>

  <div id="stytch-login"></div>
</div>

<!-- ── Dashboard (shown after authentication) ─────────────── -->

<div id="dashboard" style="display:none">
  <div class="container">

  <div class="internal-error-bar" id="internal-error"></div>

  <div class="overall-banner banner-loading" id="overall-banner">
    <span class="banner-dot"></span>
    <span id="overall-text">Checking system status&hellip;</span>
  </div>

  <div id="team-filter-bar" class="team-filter-bar"></div>

  <div id="team-summary-banner" style="display:none"></div>

  <div class="mismatch-alerts" id="mismatch-alerts"></div>

  <div id="active-issues" style="display:none"></div>

  <div id="last-updated" class="last-updated"></div>

  <div class="summary" id="summary-cards">
    <div class="summary-card" onclick="setStatusFilter('operational')" data-filter="operational">
      <div class="count count-operational" id="count-up">&ndash;</div>
      <div class="label">Operational</div>
    </div>
    <div class="summary-card" onclick="setStatusFilter('degraded')" data-filter="degraded">
      <div class="count count-degraded" id="count-degraded">&ndash;</div>
      <div class="label">Degraded</div>
    </div>
    <div class="summary-card" onclick="setStatusFilter('outage')" data-filter="outage">
      <div class="count count-outage" id="count-outage">&ndash;</div>
      <div class="label">Outage</div>
    </div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch" style="background:var(--blue);opacity:0.7"></div>
      <span>Global (vendor status page)</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch" style="background:var(--purple);opacity:0.7"></div>
      <span>Ours (Datadog monitors)</span>
    </div>
  </div>

  <div id="filter-indicator" class="filter-indicator" style="display:none"></div>

  <div id="services"></div>

  <div class="page-footer">
    <a href="index.html">View public dependency status</a>
    &nbsp;&middot;&nbsp;
    Data from vendor status pages + <a href="https://app.datadoghq.com" target="_blank" rel="noopener">Datadog</a>
    &nbsp;&middot;&nbsp;
    <span id="monitor-count"></span>
  </div>

  </div><!-- /.container -->
</div>

<script>
// ── Configuration ───────────────────────────────────────────────────────

const ENVIRONMENTS = {
  prod:    { url: "https://api.happy-health.net", label: "Production" },
  staging: { url: "https://api.happy-staging.net", label: "Staging" },
};

const params = new URLSearchParams(location.search);
const IS_LOCAL = location.hostname === "localhost" || location.hostname === "127.0.0.1";
const LOCAL_LOGGED_OUT = sessionStorage.getItem("hpy-local-logged-out") === "1";
let currentEnv = sessionStorage.getItem("hpy-env") || "prod";
let API_BASE_URL = params.get("api_url") || sessionStorage.getItem("hpy-api-url-custom") || (IS_LOCAL ? "http://localhost:8787" : ENVIRONMENTS[currentEnv]?.url) || "";
let API_KEY = sessionStorage.getItem("hpy-api-key-" + currentEnv) || params.get("api_key") || (IS_LOCAL ? "test" : "") || "";
let useCustomUrl = !!sessionStorage.getItem("hpy-api-url-custom") || !!params.get("api_url");
const STYTCH_PUBLIC_TOKEN = params.get("stytch_token") || "";
const PROXY_URL = params.get("proxy") || (IS_LOCAL ? "http://localhost:8787/proxy" : "");
let isMockData = false;
const REFRESH_INTERVAL = 60;
const HISTORY_DAYS = 90;
const STORAGE_KEY_GLOBAL = "hpy-uptime-history";
const STORAGE_KEY_INTERNAL = "hpy-uptime-internal-history";

// ── Mapping: which vendor names correspond to which internal service names ──

const GLOBAL_TO_INTERNAL = {
  "Stytch": "Stytch Auth",
  "Candid Health": "Candid Health",
  "Healthie": "Healthie",
  "Stripe": "Stripe",
  "Shopify": "Shopify",
  "Supabase": "Supabase",
  "Twilio": "Twilio SMS (US)",
  "Slack": "Slack",
  "Customer.io": "Customer.io",
  "Datadog": "Datadog",
  "Sentry": "Sentry",
  "Inngest": "Inngest",
  "Cloudflare": null,
  "Vercel": null,
};

const INTERNAL_TO_GLOBAL = {};
for (const [g, i] of Object.entries(GLOBAL_TO_INTERNAL)) {
  if (i) INTERNAL_TO_GLOBAL[i] = g;
}

// ── Team/audience mappings (includes global-only services) ───────────────

const TEAM_MAPPINGS = {
  "End Users": [
    "API Gateway", "API (Enso)", "API (CRO)",
    "Stytch Auth", "Stytch",
    "Stripe", "Shopify",
    "DynamoDB", "Supabase",
    "Twilio", "Twilio SMS (US)",
    "AWS Lambda", "AWS S3",
    "Cloudflare", "Vercel",
    "AWS RDS", "Host Health",
  ],
  "Clinicians": [
    "API Gateway",
    "Stytch Auth", "Stytch",
    "Candid Health", "Healthie", "OpenLoop",
    "DynamoDB", "Supabase",
    "Twilio", "Twilio SMS (US)",
    "AWS RDS", "Host Health",
  ],
  "Developers": [
    "Datadog", "Sentry",
    "Inngest",
    "AWS Lambda", "AWS S3",
    "AWS RDS", "Host Health", "Disk Health",
    "GitHub", "Bitbucket", "GitLab",
    "npm Registry", "PyPI",
    "Cloudflare", "Vercel",
  ],
  "Customer Support": [
    "Slack", "Customer.io", "Twilio",
    "Datadog", "Sentry",
    "Stytch Auth", "Stytch",
    "Stripe", "Shopify",
  ],
};

const TEAM_ORDER = ["All", "End Users", "Clinicians", "Developers", "Customer Support"];

// ── Fetch with timeout ──────────────────────────────────────────────────

function fetchWithTimeout(url, options = {}, timeoutMs = 15000) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  return fetch(url, { ...options, signal: controller.signal })
    .finally(() => clearTimeout(timer));
}

// ── State ───────────────────────────────────────────────────────────────

const globalState = {};  // vendor name -> { level, description }
let internalServices = []; // from Datadog API
let globalHistory = loadStorage(STORAGE_KEY_GLOBAL);
let internalHistory = loadStorage(STORAGE_KEY_INTERNAL);
let countdownSeconds = REFRESH_INTERVAL;
let countdownTimer = null;
let stytchClient = null;
let totalMonitors = 0;
const expandedServices = new Set();
let allExpanded = false;
let currentTeamFilter = "All";
let currentStatusFilter = null; // null = show all, or "operational" | "degraded" | "outage" | "mismatch"

// ── Category display order ──────────────────────────────────────────────

const CATEGORY_ORDER = [
  "Core Platform", "Authentication", "Healthcare", "Payments",
  "Database", "CMS", "Communications", "Observability", "Workflow",
  "Infrastructure", "Cloud & Hosting", "Source Control",
  "Package Registries", "Mobile Platforms", "Partner",
];

// ── Component ID filters (must be defined before GLOBAL_SERVICES) ────────

// Twilio SMS (US) — only SMS/MMS components in North America
const TWILIO_SMS_US_COMPONENT_IDS = [
  "yvvy3vlp4djf", // SMS (Programmable Messaging)
  "d1j2nx64rpq3", // MMS (Programmable Messaging)
  "x3z86l06nvl7", // Programmable Messaging API
  "7d8w22hqrh6s", // SMS Long Code, North America
  "39mb8cmw8y2v", // SMS Short Code, North America
  "32f2bm54nkvv", // SMS Toll-Free, North America
  "8vdlvw3dsq8h", // MMS Long Code, North America
  "tvjwfvczkf46", // MMS Toll-Free, North America
];

// Cloudflare — core platform services only (excludes 450+ global edge PoPs)
const CLOUDFLARE_COMPONENT_IDS = [
  "5wnz34mhfhrk", // CDN/Cache
  "dp8ppfycqxcs", // Authoritative DNS
  "g4tb35rs9yw7", // API
  "3sq3s4d20ywk", // Dashboard
  "fbvx0hxhhdj0", // CDN Cache Purge
  "ts05t1p1j7r4", // DNS Firewall
  "4l9qztbt6rbj", // DNS Root Servers
  "w4k8yvhfb3vp", // Access
];

// Segment — US region only (excludes EU)
const SEGMENT_US_COMPONENT_IDS = [
  "g6z8h6bwf010", // Data Ingestion (Tracking) API (US)
  "c13tbpl4dm8m", // Web Interface (US)
  "klyl7cz2012x", // Analytics.js CDN (US)
  "7wv8256rdp62", // Streaming Destinations (US)
  "h32n3sb6hz33", // Cloud Sources (US)
  "ylfsvnn8hcs1", // Warehouse Destinations (US)
  "804tjyrkwnlw", // Libraries (US)
  "g6ncbp86zxm7", // Engage (US)
  "58j460c4vffk", // Data Processing Pipeline (US)
  "4snztn8n32qk", // Public API (US)
  "yk53kzcsw671", // Blobstore Destinations (US)
  "w392yz67sbxp", // Data Lakes (US)
  "1jxpx3ysdvj1", // Data Deletions (US)
  "hxjkwnmnyh7r", // Linked Audiences (US)
  "yk55rmb9rlym", // Reverse ETL (US)
  "zqj3vffxvytv", // Linked Events (US)
  "m0n5pwdch93f", // Journeys (US)
];

// Sentry — US ingestion + US alerting + global services (excludes EU)
const SENTRY_US_COMPONENT_IDS = [
  "khtl9dcky3lb", // Dashboard
  "qywmfv7jr0pd", // API
  "51yszynm4xyv", // US Error Ingestion
  "bdg4djkxjxmk", // US Transaction Ingestion
  "cycj4r32g25w", // US Attachment Ingestion
  "52t4t3ww2qcn", // US Profile Ingestion
  "zxkxxtspk64g", // US Replay Ingestion
  "qd7tzrk5q8xm", // US Span Ingestion
  "6f1r28lydc6h", // US Cron Monitoring
  "7wrqyj84ltw7", // Custom Metrics (beta)
  "bctv81yt9s6w", // US Errors Alerting
  "mbhk48shsbl8", // US Transactions Alerting
  "rcdlp8rvtf7t", // US Spans Alerting
  "fvsfbxc1mb16", // US Uptime Monitoring
];

// Mixpanel — US region + global services (excludes EU/India)
const MIXPANEL_US_COMPONENT_IDS = [
  "45yb5qck0sw5", // Application Availability (US)
  "cq5ttq9czyjh", // Ingestion API Availability (US)
  "7cdmvbkr0dyq", // JavaScript Library CDN
  "tjt23lh5r46g", // Data Export
  "v1kc88rj0qmw", // Warehouse Connectors
];

// PyPI — core service only (excludes 80+ Fastly CDN edge nodes)
const PYPI_COMPONENT_IDS = [
  "06hwjcnhlz03", // pypi.org - General
  "xt7f24hjvspn", // pypi.org - CDN
  "yjlyv2k3zz3p", // pypi.org - Backends
  "frjs3hvgp2bk", // files.pythonhosted.org - Files
  "p2b1wmgvmwln", // files.pythonhosted.org - Redirects
  "nj4jx0hljzvl", // files.pythonhosted.org - Redirects Backends
  "5k8sx11bnccq", // pypi.org - Email
];

// ── Global service definitions (from public page) ───────────────────────

const GLOBAL_SERVICES = [
  sp("AWS", "Cloud & Hosting", "https://health.aws.amazon.com/health/status",
     null, "https://status.aws.amazon.com/rss/all.rss", false, "atom"),
  sp("Google Cloud", "Cloud & Hosting", "https://status.cloud.google.com",
     null, "https://status.cloud.google.com/feed.atom", true, "atom"),
  sp("Microsoft Azure", "Cloud & Hosting", "https://azure.status.microsoft/en-us/status",
     null, "https://azurestatuscdn.azureedge.net/en-us/status/feed/", true, "atom"),
  sp("Oracle Cloud", "Cloud & Hosting", "https://ocistatus.oraclecloud.com",
     null, "https://ocistatus.oraclecloud.com/api/v2/incident-summary.rss", false, "atom"),
  {
    name: "Cloudflare", category: "Cloud & Hosting",
    statusUrl: "https://www.cloudflarestatus.com",
    fetch: fetchStatuspageComponents("https://www.cloudflarestatus.com/api/v2/components.json", CLOUDFLARE_COMPONENT_IDS, "All core services operational"),
    incidentsUrl: "https://www.cloudflarestatus.com/api/v2/incidents.json",
  },
  sp("Vercel", "Cloud & Hosting", "https://www.vercel-status.com",
     "https://www.vercel-status.com"),
  {
    name: "Stytch", category: "Authentication",
    statusUrl: "https://status.stytch.com",
    fetch: fetchInstatus("https://stytch.instatus.com/summary.json"),
    historyFetch: fetchAtomHistory("https://status.stytch.com/history.atom", false),
  },
  sp("Candid Health", "Healthcare", "https://status.joincandidhealth.com",
     "https://status.joincandidhealth.com"),
  sp("Healthie", "Healthcare", "https://status.gethealthie.com",
     "https://status.gethealthie.com"),
  {
    name: "Stripe", category: "Payments",
    statusUrl: "https://status.stripe.com",
    fetch: fetchStripe("https://status.stripe.com/current"),
    historyFetch: fetchStripeHistory("https://status.stripe.com/current/full"),
    needsProxy: true,
  },
  sp("Shopify", "Payments", "https://www.shopifystatus.com",
     "https://www.shopifystatus.com"),
  sp("Supabase", "Database", "https://status.supabase.com",
     "https://status.supabase.com"),
  sp("Sanity", "CMS", "https://www.sanity-status.com",
     "https://www.sanity-status.com"),
  {
    name: "Twilio SMS (US)", category: "Communications",
    statusUrl: "https://status.twilio.com",
    fetch: fetchStatuspageComponents("https://status.twilio.com/api/v2/components.json", TWILIO_SMS_US_COMPONENT_IDS, "All SMS systems operational"),
    incidentsUrl: "https://status.twilio.com/api/v2/incidents.json",
  },
  {
    name: "Slack", category: "Communications",
    statusUrl: "https://slack-status.com",
    fetch: fetchSlack("https://slack-status.com/api/v2.0.0/current"),
    historyFetch: fetchSlackHistory("https://slack-status.com/api/v2.0.0/history"),
  },
  sp("Customer.io", "Communications", "https://status.customerio.com",
     "https://status.customerio.com"),
  {
    name: "Segment", category: "Communications",
    statusUrl: "https://status.segment.com",
    fetch: fetchStatuspageComponents("https://status.segment.com/api/v2/components.json", SEGMENT_US_COMPONENT_IDS, "All US systems operational"),
    incidentsUrl: "https://status.segment.com/api/v2/incidents.json",
  },
  sp("Datadog", "Observability", "https://status.datadoghq.com",
     "https://status.datadoghq.com"),
  {
    name: "Sentry", category: "Observability",
    statusUrl: "https://status.sentry.io",
    fetch: fetchStatuspageComponents("https://status.sentry.io/api/v2/components.json", SENTRY_US_COMPONENT_IDS, "All US systems operational"),
    incidentsUrl: "https://status.sentry.io/api/v2/incidents.json",
  },
  {
    name: "Mixpanel", category: "Observability",
    statusUrl: "https://www.mixpanelstatus.com",
    fetch: fetchStatuspageComponents("https://www.mixpanelstatus.com/api/v2/components.json", MIXPANEL_US_COMPONENT_IDS, "All US systems operational"),
    incidentsUrl: "https://www.mixpanelstatus.com/api/v2/incidents.json",
  },
  sp("Inngest", "Workflow", "https://status.inngest.com",
     "https://status.inngest.com"),
  sp("GitHub", "Source Control", "https://www.githubstatus.com",
     "https://www.githubstatus.com"),
  sp("Bitbucket", "Source Control", "https://bitbucket.status.atlassian.com",
     "https://bitbucket.status.atlassian.com"),
  {
    name: "GitLab", category: "Source Control",
    statusUrl: "https://status.gitlab.com",
    fetch: fetchAtomFeed("https://status.gitlab.com/pages/5b36dc6502d06804c08349f7/rss", false),
    historyFetch: fetchStatusIoHistory("https://status.gitlab.com/pages/5b36dc6502d06804c08349f7/status_chart/component/5b36e05f02d06804c0834a09/uptime"),
  },
  sp("npm Registry", "Package Registries", "https://status.npmjs.org",
     "https://status.npmjs.org"),
  {
    name: "PyPI", category: "Package Registries",
    statusUrl: "https://status.python.org",
    fetch: fetchStatuspageComponents("https://status.python.org/api/v2/components.json", PYPI_COMPONENT_IDS, "All systems operational"),
    incidentsUrl: "https://status.python.org/api/v2/incidents.json",
  },
  {
    name: "Apple Developer", category: "Mobile Platforms",
    statusUrl: "https://developer.apple.com/system-status/",
    fetch: fetchApple("https://www.apple.com/support/systemstatus/data/developer/system_status_en_US.js"),
    needsProxy: true,
  },
  {
    name: "Eve", category: "Partner",
    statusUrl: "https://status.eve.co",
    fetch: fetchUptimeRobot("https://status.eve.co/api/getMonitorList/BQLq3SDoBo"),
    historyFetch: fetchUptimeRobotHistory("https://status.eve.co/api/getMonitorList/BQLq3SDoBo"),
  },
];

function sp(name, category, statusUrl, statuspageBase, feedUrl, needsProxy, feedType) {
  const svc = { name, category, statusUrl };
  if (statuspageBase) {
    svc.fetch = fetchStatuspage(statuspageBase + "/api/v2/status.json");
    svc.incidentsUrl = statuspageBase + "/api/v2/incidents.json";
  } else if (feedUrl) {
    svc.fetch = fetchAtomFeed(feedUrl, !!needsProxy);
    svc.needsProxy = !!needsProxy;
  }
  return svc;
}

// ── Fetcher factories (same as public page) ─────────────────────────────

function proxyWrap(url, needsProxy) {
  if (needsProxy && PROXY_URL) {
    const sep = PROXY_URL.includes("?") ? "&" : "?";
    return PROXY_URL + sep + "url=" + encodeURIComponent(url);
  }
  return url;
}

function fetchStatuspage(apiUrl) {
  return async function () {
    const resp = await fetchWithTimeout(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const indicator = data.status?.indicator || "none";
    const description = data.status?.description || "Unknown";
    const levelMap = { none: "operational", minor: "degraded", major: "partial", critical: "major" };
    return { level: levelMap[indicator] || "operational", description };
  };
}

function fetchInstatus(apiUrl) {
  return async function () {
    const resp = await fetchWithTimeout(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const status = data.page?.status || "UNKNOWN";
    const levelMap = { UP: "operational", HASISSUES: "degraded", UNDERMAINTENANCE: "degraded" };
    return {
      level: levelMap[status] || "error",
      description: status === "UP" ? "All Systems Operational" : status,
    };
  };
}

function fetchSlack(apiUrl) {
  return async function () {
    const resp = await fetchWithTimeout(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const incidents = data.active_incidents || [];
    if (data.status === "ok" || incidents.length === 0) {
      return { level: "operational", description: "All Systems Operational" };
    }
    const inc = incidents[0];
    const level = inc?.type === "outage" ? "major" : "degraded";
    return { level, description: inc?.title || "Active incident" };
  };
}

function fetchUptimeRobot(apiUrl) {
  return async function () {
    const resp = await fetchWithTimeout(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const counts = data.statistics?.counts || {};
    if (counts.down > 0) {
      return { level: "major", description: counts.down + " of " + counts.total + " monitors down" };
    }
    return { level: "operational", description: "All monitors up" };
  };
}

function fetchStripe(apiUrl) {
  return async function () {
    const url = proxyWrap(apiUrl, true);
    const resp = await fetchWithTimeout(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const levelMap = { up: "operational", degraded: "degraded", down: "major" };
    return {
      level: levelMap[data.largestatus] || "error",
      description: data.message || "Unknown",
    };
  };
}

// ── Component-scoped Statuspage fetcher (filters to specific component IDs) ──

function fetchStatuspageComponents(apiUrl, componentIds, okMessage) {
  const idSet = new Set(componentIds);
  return async function () {
    const resp = await fetchWithTimeout(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    const components = (data.components || []).filter(c => idSet.has(c.id));
    const statusMap = { operational: 0, degraded_performance: 1, partial_outage: 2, major_outage: 3 };
    const levelMap = { operational: "operational", degraded_performance: "degraded", partial_outage: "partial", major_outage: "major" };
    let worstStatus = "operational";
    let worstSev = 0;
    const issues = [];
    for (const c of components) {
      const sev = statusMap[c.status] ?? 0;
      if (sev > worstSev) { worstSev = sev; worstStatus = c.status; }
      if (sev > 0) issues.push(c.name + ": " + c.status.replace(/_/g, " "));
    }
    return {
      level: levelMap[worstStatus] || "operational",
      description: issues.length > 0 ? issues.join("; ") : (okMessage || "All systems operational"),
    };
  };
}

function fetchAtomFeed(feedUrl, needsProxy) {
  return async function () {
    const url = proxyWrap(feedUrl, needsProxy);
    const resp = await fetchWithTimeout(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const text = await resp.text();
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    if (!xml.querySelector("parsererror")) {
      const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
      const entries = xml.querySelectorAll("entry, item");
      const recent = [];
      for (const entry of entries) {
        const updated = entry.querySelector("updated, pubDate");
        if (updated) {
          const date = new Date(updated.textContent.trim());
          if (date.getTime() > oneDayAgo) {
            recent.push(entry.querySelector("title")?.textContent?.trim() || "");
          }
        }
      }
      if (recent.length === 0) return { level: "operational", description: "No recent incidents" };
      return { level: classifyIncidentTitle(recent[0]), description: recent[0] };
    }
    const html = parser.parseFromString(text, "text/html");
    const bodyText = html.body?.textContent || "";
    if (/all systems operational|no issues/i.test(bodyText)) return { level: "operational", description: "All Systems Operational" };
    if (/operational/i.test(bodyText)) return { level: "operational", description: "Operational" };
    return { level: "error", description: "Could not parse status" };
  };
}

function fetchApple(apiUrl) {
  return async function () {
    const url = proxyWrap(apiUrl, true);
    const resp = await fetchWithTimeout(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const text = await resp.text();
    const match = text.match(/jsonCallback\((.+)\)/s);
    if (!match) throw new Error("Could not parse JSONP");
    const data = JSON.parse(match[1]);
    const svcs = data.services || [];
    const issues = svcs.filter(s => s.events?.length > 0 && s.events.some(e => e.statusType !== "resolved"));
    if (issues.length === 0) return { level: "operational", description: "All Developer Services Operational" };
    return { level: "degraded", description: issues.length + " service(s) with active events" };
  };
}



// ── History fetcher factories ─────────────────────────────────────────────
// These return a function that populates globalHistory[name] with 90 days of data.

function fetchStripeHistory(apiUrl) {
  // status.stripe.com/current/full returns 90 days of daily uptime data per sub-service
  return async function (name) {
    const url = proxyWrap(apiUrl, true);
    const resp = await fetchWithTimeout(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    if (!globalHistory[name]) globalHistory[name] = {};
    const days = getLast90Days();
    // Aggregate worst status across all Stripe sub-services per day
    const dayStatus = {};
    for (const svc of data.uptimeData || []) {
      for (const entry of svc.uptime || []) {
        const d = new Date(entry.date);
        const dayKey = getDayKey(d);
        let level = "operational";
        if (entry.downtime > 0) level = "major";
        else if (entry.degraded > 0) level = "degraded";
        else if (entry.delayed > 0) level = "degraded";
        const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
        const existing = dayStatus[dayKey];
        if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
          dayStatus[dayKey] = level;
        }
      }
    }
    for (const day of days) {
      const level = dayStatus[day] || "operational";
      const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
      const existing = globalHistory[name][day];
      if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
        globalHistory[name][day] = level;
      }
    }
  };
}

function fetchSlackHistory(apiUrl) {
  // slack-status.com/api/v2.0.0/history returns all past incidents
  return async function (name) {
    const resp = await fetchWithTimeout(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const incidents = await resp.json();
    if (!globalHistory[name]) globalHistory[name] = {};
    const days = getLast90Days();
    const ninetyDaysAgo = Date.now() - HISTORY_DAYS * 24 * 60 * 60 * 1000;
    for (const inc of incidents) {
      const created = new Date(inc.date_created);
      if (created.getTime() < ninetyDaysAgo) continue;
      const dayKey = getDayKey(created);
      const level = inc.type === "outage" ? "major" : "degraded";
      const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
      const existing = globalHistory[name][dayKey];
      if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
        globalHistory[name][dayKey] = level;
      }
    }
    for (const day of days) {
      if (!globalHistory[name][day]) {
        globalHistory[name][day] = "operational";
      }
    }
  };
}

function fetchUptimeRobotHistory(apiUrl) {
  // UptimeRobot getMonitorList already returns dailyRatios with 90 days of data
  return async function (name) {
    const resp = await fetchWithTimeout(apiUrl, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    if (!globalHistory[name]) globalHistory[name] = {};
    const monitors = data.psp?.monitors || [];
    const days = getLast90Days();
    // Aggregate worst across all monitors per day
    const dayStatus = {};
    for (const mon of monitors) {
      for (const entry of mon.dailyRatios || []) {
        const dayKey = entry.date;
        let level = "operational";
        const ratio = parseFloat(entry.ratio);
        if (ratio < 95) level = "major";
        else if (ratio < 99.5) level = "degraded";
        const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
        const existing = dayStatus[dayKey];
        if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
          dayStatus[dayKey] = level;
        }
      }
    }
    for (const day of days) {
      const level = dayStatus[day] || "operational";
      const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
      const existing = globalHistory[name][day];
      if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
        globalHistory[name][day] = level;
      }
    }
  };
}

function fetchStatusIoHistory(uptimeUrl) {
  // Status.io status_chart uptime endpoint returns 91 days of daily status
  return async function (name) {
    let resp = await fetchWithTimeout(uptimeUrl, { cache: "no-store" }).catch(() => null);
    // Fallback to proxy if CORS blocks direct fetch
    if (!resp || !resp.ok) {
      const proxied = proxyWrap(uptimeUrl, true);
      if (proxied !== uptimeUrl) resp = await fetchWithTimeout(proxied, { cache: "no-store" });
    }
    if (!resp || !resp.ok) throw new Error("HTTP " + (resp?.status || "fetch failed"));
    const data = await resp.json();
    if (!globalHistory[name]) globalHistory[name] = {};
    const allDays = getLast90Days();
    for (const entry of data.days || []) {
      // entry.date is like "21 Nov 2025"
      const d = new Date(entry.date + " 12:00:00");
      if (isNaN(d.getTime())) continue;
      const dayKey = getDayKey(d);
      let level = "operational";
      if (entry.status >= 500) level = "major";
      else if (entry.status >= 300) level = "degraded";
      const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
      const existing = globalHistory[name][dayKey];
      if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
        globalHistory[name][dayKey] = level;
      }
    }
    for (const day of allDays) {
      if (!globalHistory[name][day]) {
        globalHistory[name][day] = "operational";
      }
    }
  };
}

function fetchAtomHistory(feedUrl, needsProxy) {
  // Parse an Atom/RSS feed and backfill 90 days of history from incident entries
  return async function (name) {
    const url = proxyWrap(feedUrl, needsProxy);
    const resp = await fetchWithTimeout(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const text = await resp.text();
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    if (xml.querySelector("parsererror")) throw new Error("XML parse error");

    if (!globalHistory[name]) globalHistory[name] = {};
    const days = getLast90Days();
    const ninetyDaysAgo = Date.now() - HISTORY_DAYS * 24 * 60 * 60 * 1000;
    const entries = xml.querySelectorAll("entry, item");
    for (const entry of entries) {
      const published = entry.querySelector("published, pubDate, updated");
      if (!published) continue;
      const date = new Date(published.textContent.trim());
      if (isNaN(date.getTime()) || date.getTime() < ninetyDaysAgo) continue;
      const dayKey = getDayKey(date);
      const title = entry.querySelector("title")?.textContent?.trim() || "";
      const level = classifyIncidentTitle(title);
      if (level === "operational") continue; // resolved incidents don't count
      const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
      const existing = globalHistory[name][dayKey];
      if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
        globalHistory[name][dayKey] = level;
      }
    }
    // Fill remaining days as operational
    for (const day of days) {
      if (!globalHistory[name][day]) {
        globalHistory[name][day] = "operational";
      }
    }
  };
}

function classifyIncidentTitle(title) {
  const t = title.toLowerCase();
  if (/resolved|completed|scheduled/i.test(t)) return "operational";
  if (/major|critical|outage/i.test(t)) return "major";
  if (/partial/i.test(t)) return "partial";
  if (/degraded|elevated|minor|investigating|monitoring/i.test(t)) return "degraded";
  return "degraded";
}

// ── Auth ────────────────────────────────────────────────────────────────

function setLoginEnv(env) {
  currentEnv = env;
  document.querySelectorAll("#login-env-toggle .env-toggle-btn").forEach(b => {
    b.classList.toggle("active", b.dataset.env === env);
  });
  // Restore saved key for this env
  const saved = sessionStorage.getItem("hpy-api-key-" + env);
  if (saved) document.getElementById("input-api-key").value = saved;
  else document.getElementById("input-api-key").value = "";
}

function toggleCustomUrl(e) {
  e.preventDefault();
  const row = document.getElementById("custom-url-row");
  const link = document.getElementById("custom-url-link");
  const toggle = document.getElementById("login-env-toggle");
  useCustomUrl = !useCustomUrl;
  row.style.display = useCustomUrl ? "block" : "none";
  toggle.style.display = useCustomUrl ? "none" : "flex";
  link.textContent = useCustomUrl ? "Use environment presets" : "Use custom URL";
}

function unlockWithApiKey() {
  const keyInput = document.getElementById("input-api-key").value.trim();
  if (!keyInput) { document.getElementById("input-api-key").focus(); return; }

  if (IS_LOCAL) {
    // On localhost, always use local server
    API_BASE_URL = "http://localhost:8787";
    sessionStorage.removeItem("hpy-local-logged-out");
  } else if (useCustomUrl) {
    const urlInput = document.getElementById("input-api-url").value.trim();
    if (!urlInput) { document.getElementById("input-api-url").focus(); return; }
    API_BASE_URL = urlInput;
    sessionStorage.setItem("hpy-api-url-custom", urlInput);
  } else {
    API_BASE_URL = ENVIRONMENTS[currentEnv].url;
    sessionStorage.removeItem("hpy-api-url-custom");
  }

  API_KEY = keyInput;
  sessionStorage.setItem("hpy-env", currentEnv);
  sessionStorage.setItem("hpy-api-key-" + currentEnv, keyInput);
  showDashboard();
  refreshAll();
}

// Allow Enter key to submit
document.addEventListener("keydown", function(e) {
  if (e.key === "Enter" && document.getElementById("login-gate").style.display !== "none") {
    unlockWithApiKey();
  }
});

async function initAuth() {
  // On localhost, always bypass login gate — no auth needed for local dev
  if (IS_LOCAL) {
    API_KEY = "test";
    API_BASE_URL = "http://localhost:8787";
    showDashboard();
    refreshAll();
    return;
  }

  // Restore login form state from sessionStorage
  if (currentEnv) setLoginEnv(currentEnv);
  if (useCustomUrl) {
    document.getElementById("custom-url-row").style.display = "block";
    document.getElementById("login-env-toggle").style.display = "none";
    document.getElementById("custom-url-link").textContent = "Use environment presets";
    document.getElementById("input-api-url").value = API_BASE_URL;
  }

  if (API_KEY) {
    showDashboard();
    refreshAll();
    return;
  }

  if (!STYTCH_PUBLIC_TOKEN) {
    document.getElementById("stytch-login").innerHTML =
      '<p style="color:var(--text-muted);font-size:0.78rem;padding:0.75rem;text-align:center">' +
      'Stytch auth available when deployed with <code>stytch_token</code> parameter.</p>';
    return;
  }

  const script = document.createElement("script");
  script.src = "https://js.stytch.com/stytch.js";
  script.onerror = () => {
    console.error("Failed to load Stytch SDK");
    document.getElementById("stytch-login").innerHTML =
      '<p style="color:var(--text-muted);font-size:0.85rem">Authentication service unavailable. Try refreshing the page.</p>';
  };
  script.onload = () => {
    stytchClient = new window.StytchUIClient(STYTCH_PUBLIC_TOKEN);
    const session = stytchClient.session.getSync();
    if (session) {
      showDashboard();
      setUserEmail();
      refreshAll();
      return;
    }
    stytchClient.mountLogin({
      elementId: "#stytch-login",
      config: {
        products: ["emailMagicLinks"],
        emailMagicLinksOptions: {
          loginRedirectURL: window.location.href,
          signupRedirectURL: window.location.href,
        },
      },
      callbacks: {
        onEvent: (event) => {
          if (event.type === "AUTHENTICATE_FLOW_COMPLETE") {
            showDashboard();
            setUserEmail();
            refreshAll();
          }
        },
      },
    });
  };
  document.head.appendChild(script);
}

function showDashboard() {
  document.getElementById("login-gate").style.display = "none";
  document.getElementById("dashboard").style.display = "block";
  document.getElementById("top-bar-actions").style.display = "flex";
  if (IS_LOCAL) {
    // On localhost: hide env toggle, show local indicator
    document.getElementById("topbar-env-toggle").style.display = "none";
    document.getElementById("local-dev-badge").style.display = "";
  } else if (!useCustomUrl) {
    const toggle = document.getElementById("topbar-env-toggle");
    toggle.style.display = "flex";
    toggle.querySelectorAll(".env-toggle-btn").forEach(b => {
      b.classList.toggle("active", b.dataset.env === currentEnv);
    });
  }
  startCountdown();
}

function setUserEmail() {
  if (!stytchClient) return;
  const user = stytchClient.user.getSync();
  if (user?.emails?.[0]?.email) {
    document.getElementById("user-email").textContent = user.emails[0].email;
  }
}

function logout() {
  if (stytchClient) stytchClient.session.revoke();
  sessionStorage.removeItem("hpy-env");
  sessionStorage.removeItem("hpy-api-url-custom");
  for (const env of Object.keys(ENVIRONMENTS)) {
    sessionStorage.removeItem("hpy-api-key-" + env);
  }
  if (IS_LOCAL) {
    sessionStorage.setItem("hpy-local-logged-out", "1");
  }
  location.reload();
}

function switchEnv(env) {
  if (IS_LOCAL) return; // Env toggle disabled on localhost
  if (env === currentEnv && !useCustomUrl) return;
  currentEnv = env;
  useCustomUrl = false;
  sessionStorage.removeItem("hpy-api-url-custom");
  sessionStorage.setItem("hpy-env", env);
  API_BASE_URL = ENVIRONMENTS[env].url;
  API_KEY = sessionStorage.getItem("hpy-api-key-" + env) || "";

  document.querySelectorAll("#topbar-env-toggle .env-toggle-btn").forEach(b => {
    b.classList.toggle("active", b.dataset.env === env);
  });

  if (!API_KEY) {
    // No key saved for this env — show login gate
    document.getElementById("dashboard").style.display = "none";
    document.getElementById("login-gate").style.display = "";
    document.getElementById("top-bar-actions").style.display = "none";
    document.getElementById("topbar-env-toggle").style.display = "none";
    setLoginEnv(env);
    return;
  }

  // Reset internal data for new env
  internalServices = [];
  internalHistory = loadStorage(STORAGE_KEY_INTERNAL);
  refreshAll();
}

function toggleExpandAll() {
  const unified = buildUnifiedServiceList();
  const dualServices = unified.filter(s => s.global && s.internal);
  if (allExpanded) {
    expandedServices.clear();
    allExpanded = false;
  } else {
    for (const svc of dualServices) expandedServices.add(svc.name);
    allExpanded = true;
  }
  const btn = document.getElementById("expand-all-btn");
  if (btn) btn.textContent = allExpanded ? "Collapse All" : "Expand All";
  render();
}

function getAuthHeaders() {
  const headers = { "Content-Type": "application/json" };
  if (API_KEY) {
    headers["API_KEY"] = API_KEY;
  } else if (stytchClient) {
    const tokens = stytchClient.session.getTokens();
    if (tokens?.session_jwt) {
      headers["Authorization"] = "Bearer " + tokens.session_jwt;
    }
  }
  return headers;
}

// ── Helpers ──────────────────────────────────────────────────────────────

function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

function buildDatadogUrl(tags) {
  if (!tags || tags.length === 0) return null;
  // Build a Datadog monitors manage URL filtered by the first tag
  const query = tags.map(t => "tag:" + t).join(" ");
  return "https://app.datadoghq.com/monitors/manage?q=" + encodeURIComponent(query);
}

function escapeHtml(s) {
  const d = document.createElement("div");
  d.textContent = s;
  return d.innerHTML;
}

function getDayKey(date) { return date.toISOString().split("T")[0]; }

function getLast90Days() {
  const days = [];
  const now = new Date(); // Use single base date to avoid midnight boundary issues
  for (let i = HISTORY_DAYS - 1; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(now.getDate() - i);
    days.push(getDayKey(d));
  }
  return days;
}

function formatDate(dateStr) {
  const d = new Date(dateStr + "T12:00:00");
  return d.toLocaleDateString("en-US", { month: "short", day: "numeric" });
}

// ── History (localStorage) ──────────────────────────────────────────────

function loadStorage(key) {
  try {
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : {};
  } catch { return {}; }
}

function saveStorage(key, data) {
  try {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - (HISTORY_DAYS + 5));
    const cutoffStr = getDayKey(cutoff);
    for (const svc of Object.keys(data)) {
      for (const day of Object.keys(data[svc])) {
        if (day < cutoffStr) delete data[svc][day];
      }
    }
    localStorage.setItem(key, JSON.stringify(data));
  } catch { /* storage unavailable */ }
}

function recordGlobalStatus(name, level) {
  const today = getDayKey(new Date());
  if (!globalHistory[name]) globalHistory[name] = {};
  const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3, error: -1, loading: -1 };
  const current = globalHistory[name][today];
  const curSev = SEVERITY[current] ?? -1;
  const newSev = SEVERITY[level] ?? -1;
  if (newSev > curSev || curSev < 0) globalHistory[name][today] = level;
}

function recordInternalStatus(name, level) {
  // Don't record "unknown" — it means "not monitored", not an actual status
  if (level === "unknown") return;
  const today = getDayKey(new Date());
  if (!internalHistory[name]) internalHistory[name] = {};
  const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
  const current = internalHistory[name][today];
  const curSev = SEVERITY[current] ?? -1;
  const newSev = SEVERITY[level] ?? -1;
  if (newSev > curSev || curSev < 0) internalHistory[name][today] = level;
}

// ── Data fetching ───────────────────────────────────────────────────────

async function fetchGlobalStatuses() {
  const promises = GLOBAL_SERVICES.map(async (svc) => {
    if (svc.needsProxy && !PROXY_URL) {
      globalState[svc.name] = { level: "error", description: "Needs CORS proxy" };
      return;
    }
    try {
      const result = await svc.fetch();
      globalState[svc.name] = result;
      recordGlobalStatus(svc.name, result.level);
    } catch (e) {
      globalState[svc.name] = { level: "error", description: "Failed: " + e.message };
    }
  });
  await Promise.allSettled(promises);
  saveStorage(STORAGE_KEY_GLOBAL, globalHistory);
}

async function fetchInternalStatuses() {
  if (!API_BASE_URL) return;
  try {
    const resp = await fetchWithTimeout(API_BASE_URL + "/v2/status/internal", {
      headers: getAuthHeaders(),
      cache: "no-store",
    });
    if (resp.status === 401 || resp.status === 403) {
      renderError("Authentication failed. Please sign in again.");
      return;
    }
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    internalServices = data.services || [];
    totalMonitors = data.total_monitors || 0;
    isMockData = !!data.mock;

    for (const svc of internalServices) {
      recordInternalStatus(svc.name, svc.level);
      // Purge stale history for unmonitored services (e.g. leftover mock data)
      if (svc.level === "unknown" && internalHistory[svc.name]) {
        delete internalHistory[svc.name];
      }
    }
    saveStorage(STORAGE_KEY_INTERNAL, internalHistory);

    // Show mock/live indicator
    updateDataSourceBadge(data);
  } catch (e) {
    console.error("Internal status fetch failed:", e);
    renderInternalError(e.message);
  }
}

let _refreshing = false;
async function refreshAll() {
  if (_refreshing) return; // Prevent overlapping refreshes
  _refreshing = true;
  countdownSeconds = REFRESH_INTERVAL;

  // Clear previous error state
  const errEl = document.getElementById("internal-error");
  if (errEl) errEl.style.display = "none";

  // Initialize loading state
  for (const svc of GLOBAL_SERVICES) {
    if (!globalState[svc.name]) {
      globalState[svc.name] = { level: "loading", description: "Checking..." };
    }
  }

  render();

  // Fetch both in parallel
  await Promise.allSettled([
    fetchGlobalStatuses(),
    fetchInternalStatuses(),
  ]);

  render();

  const monitorText = totalMonitors
    ? totalMonitors + (isMockData ? " monitors (mock)" : " Datadog monitors tracked")
    : "";
  const monEl = document.getElementById("monitor-count");
  if (monEl) monEl.textContent = monitorText;

  // Update "last updated" timestamp
  const lastUpdatedEl = document.getElementById("last-updated");
  if (lastUpdatedEl) {
    const now = new Date();
    lastUpdatedEl.textContent = "Updated " + now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }

  // Backfill global history
  populateIncidentHistory();
  _refreshing = false;
}

async function populateIncidentHistory() {
  const days = getLast90Days();
  const ninetyDaysAgo = Date.now() - HISTORY_DAYS * 24 * 60 * 60 * 1000;

  const promises = [];

  // Statuspage.io services (have incidentsUrl)
  for (const svc of GLOBAL_SERVICES.filter(s => s.incidentsUrl)) {
    promises.push((async () => {
      try {
        const resp = await fetchWithTimeout(svc.incidentsUrl, { cache: "no-store" });
        if (!resp.ok) return;
        const data = await resp.json();
        if (!globalHistory[svc.name]) globalHistory[svc.name] = {};
        for (const inc of data.incidents || []) {
          const dateStr = inc.created_at?.split("T")[0];
          if (!dateStr) continue;
          if (new Date(dateStr + "T00:00:00").getTime() < ninetyDaysAgo) continue;
          const impactMap = { none: null, minor: "degraded", major: "partial", critical: "major" };
          const level = impactMap[inc.impact];
          if (!level) continue;
          const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3 };
          const existing = globalHistory[svc.name][dateStr];
          if (!existing || (SEVERITY[level] || 0) > (SEVERITY[existing] || 0)) {
            globalHistory[svc.name][dateStr] = level;
          }
        }
        for (const day of days) {
          if (!globalHistory[svc.name][day]) {
            globalHistory[svc.name][day] = "operational";
          }
        }
      } catch { /* ignore */ }
    })());
  }

  // Custom history fetchers (Stripe, Slack, Eve, GitLab, etc.)
  for (const svc of GLOBAL_SERVICES.filter(s => s.historyFetch)) {
    promises.push((async () => {
      try {
        await svc.historyFetch(svc.name);
      } catch (e) {
        console.warn("History fetch failed for " + svc.name + ":", e.message);
      }
    })());
  }

  if (promises.length === 0) return;
  await Promise.allSettled(promises);
  saveStorage(STORAGE_KEY_GLOBAL, globalHistory);
  render();
}

// ── Mismatch detection ──────────────────────────────────────────────────

function detectMismatches() {
  const mismatches = [];
  const internalByName = {};
  for (const svc of internalServices) internalByName[svc.name] = svc;

  for (const [globalName, internalName] of Object.entries(GLOBAL_TO_INTERNAL)) {
    if (!internalName) continue;
    const g = globalState[globalName];
    const i = internalByName[internalName];
    if (!g || !i) continue;
    if (g.level === "loading" || g.level === "error") continue;

    const gBad = g.level === "major" || g.level === "partial" || g.level === "degraded";
    const iBad = i.level === "major" || i.level === "partial" || i.level === "degraded";

    if (!gBad && iBad) {
      mismatches.push({
        type: "ours-down",
        service: globalName,
        message: globalName + " reports operational, but our Datadog monitors show issues",
        detail: "Check API keys, rate limits, or configuration. The vendor is fine but our integration is not.",
        globalLevel: g.level,
        internalLevel: i.level,
      });
    } else if (gBad && !iBad) {
      mismatches.push({
        type: "vendor-down",
        service: globalName,
        message: globalName + " is reporting issues, but not affecting us yet",
        detail: "Vendor outage in progress. Monitor for cascading impact.",
        globalLevel: g.level,
        internalLevel: i.level,
      });
    } else if (gBad && iBad) {
      mismatches.push({
        type: "both-down",
        service: globalName,
        message: globalName + " outage is affecting our systems",
        detail: "Vendor issue confirmed + our monitors alerting. Likely caused by the vendor outage.",
        globalLevel: g.level,
        internalLevel: i.level,
      });
    }
  }

  return mismatches;
}

// ── Rendering ───────────────────────────────────────────────────────────

function buildUnifiedServiceList() {
  // Build a unified list: internal services first (with matched global),
  // then remaining global-only services.
  const list = [];
  const usedGlobalNames = new Set();
  const internalByName = {};
  for (const svc of internalServices) internalByName[svc.name] = svc;

  // Internal services (may have matched global)
  for (const intSvc of internalServices) {
    const globalName = INTERNAL_TO_GLOBAL[intSvc.name];
    const globalSvc = globalName ? GLOBAL_SERVICES.find(s => s.name === globalName) : null;
    const gState = globalName ? globalState[globalName] : null;

    list.push({
      name: intSvc.name,
      displayName: globalName || intSvc.name,
      category: intSvc.category,
      statusUrl: globalSvc?.statusUrl || null,
      global: gState && gState.level !== "loading" ? gState : null,
      internal: { level: intSvc.level, description: intSvc.description },
      ddTags: intSvc.tags || [],
      globalHistoryKey: globalName,
      internalHistoryKey: intSvc.name,
    });

    if (globalName) usedGlobalNames.add(globalName);
  }

  // Global-only services
  for (const svc of GLOBAL_SERVICES) {
    if (usedGlobalNames.has(svc.name)) continue;
    const gState = globalState[svc.name];

    list.push({
      name: svc.name,
      displayName: svc.name,
      category: svc.category,
      statusUrl: svc.statusUrl,
      global: gState || null,
      internal: null,
      globalHistoryKey: svc.name,
      internalHistoryKey: null,
    });
  }

  return list;
}

function isServiceInTeam(svc, team) {
  if (team === "All") return true;
  const teamServices = TEAM_MAPPINGS[team] || [];
  // Check against service name and display name (covers global-only like "Stytch" vs "Stytch Auth")
  return teamServices.includes(svc.name) || teamServices.includes(svc.displayName);
}

function getTeamWorstLevel(team) {
  const unified = buildUnifiedServiceList();
  const teamSvcs = unified.filter(s => isServiceInTeam(s, team));
  const levels = [];
  for (const svc of teamSvcs) {
    if (svc.global && svc.global.level !== "loading" && svc.global.level !== "error") levels.push(svc.global.level);
    if (svc.internal && svc.internal.level !== "unknown") levels.push(svc.internal.level);
  }
  return getWorstLevel(levels);
}

function renderFilterBar() {
  const bar = document.getElementById("team-filter-bar");
  bar.innerHTML = "";
  for (const team of TEAM_ORDER) {
    const btn = document.createElement("button");
    btn.className = "team-pill" + (currentTeamFilter === team ? " active" : "");
    const dotLevel = team === "All" ? null : getTeamWorstLevel(team);
    let dotHtml = "";
    if (team !== "All" && dotLevel) {
      const dotClass = dotLevel === "major" ? "team-dot-major"
        : (dotLevel === "degraded" || dotLevel === "partial") ? "team-dot-degraded"
        : dotLevel === "operational" ? "team-dot-operational"
        : "team-dot-unknown";
      dotHtml = '<span class="team-dot ' + dotClass + '"></span>';
    }
    btn.innerHTML = dotHtml + escapeHtml(team);
    btn.addEventListener("click", () => setTeamFilter(team));
    bar.appendChild(btn);
  }
}

function setTeamFilter(team) {
  currentTeamFilter = team;
  currentStatusFilter = null; // reset status filter when switching teams
  render();
}

function setStatusFilter(filter) {
  // Toggle: clicking the active filter clears it; null always clears
  currentStatusFilter = (filter === null || currentStatusFilter === filter) ? null : filter;
  render();
}

function isServiceUnmonitored(svc) {
  return svc.internal && svc.internal.level === "unknown";
}

function getServiceWorstKnownLevel(svc) {
  const levels = [];
  if (svc.global && svc.global.level !== "loading" && svc.global.level !== "error") levels.push(svc.global.level);
  if (svc.internal && svc.internal.level !== "unknown") levels.push(svc.internal.level);
  return getWorstLevel(levels);
}

function serviceMatchesStatusFilter(svc, filter) {
  const worst = getServiceWorstKnownLevel(svc);
  if (filter === "outage") return worst === "major";
  if (filter === "degraded") return worst === "degraded" || worst === "partial";
  if (filter === "operational") return worst === "operational" || worst === "unknown";
  return true;
}

function renderTeamSummary(filtered) {
  const banner = document.getElementById("team-summary-banner");
  if (currentTeamFilter === "All") {
    banner.style.display = "none";
    return;
  }

  let op = 0, deg = 0, outage = 0, unmon = 0;
  for (const svc of filtered) {
    const levels = [];
    if (svc.global && svc.global.level !== "loading" && svc.global.level !== "error") levels.push(svc.global.level);
    if (svc.internal && svc.internal.level !== "unknown") levels.push(svc.internal.level);
    if (svc.internal && svc.internal.level === "unknown") unmon++;

    const worst = getWorstLevel(levels);
    if (worst === "operational") op++;
    else if (worst === "degraded" || worst === "partial") deg++;
    else if (worst === "major") outage++;
  }

  const parts = [];
  if (op > 0) parts.push('<span style="color:var(--green)">' + op + ' operational</span>');
  if (deg > 0) parts.push('<span style="color:var(--yellow)">' + deg + ' degraded</span>');
  if (outage > 0) parts.push('<span style="color:var(--red)">' + outage + ' outage</span>');
  if (unmon > 0) parts.push('<span style="color:var(--text-muted)">' + unmon + ' not monitored</span>');

  banner.style.display = "flex";
  banner.className = "team-summary-banner";
  banner.innerHTML =
    '<span class="team-summary-label">' + escapeHtml(currentTeamFilter) + '</span>' +
    '<span class="team-summary-detail">' + filtered.length + ' services &mdash; ' + parts.join(', ') + '</span>';
}

function render() {
  const container = document.getElementById("services");
  container.innerHTML = "";

  const unified = buildUnifiedServiceList();
  let filtered = unified.filter(s => isServiceInTeam(s, currentTeamFilter));

  renderFilterBar();
  renderTeamSummary(filtered);

  // Show/hide summary cards based on filter
  const summaryEl = document.getElementById("summary-cards");
  if (summaryEl) {
    summaryEl.style.display = currentTeamFilter === "All" ? "flex" : "none";
    // Highlight active status filter card
    summaryEl.querySelectorAll(".summary-card").forEach(card => {
      card.classList.toggle("active", card.dataset.filter === currentStatusFilter);
    });
  }

  // Render active filter indicator
  const indicatorEl = document.getElementById("filter-indicator");
  if (indicatorEl) {
    if (currentStatusFilter) {
      const labels = { operational: "Operational", degraded: "Degraded", outage: "Outage" };
      indicatorEl.style.display = "flex";
      indicatorEl.innerHTML =
        'Showing: <span class="filter-label">' + (labels[currentStatusFilter] || currentStatusFilter) +
        ' <span class="filter-clear" onclick="setStatusFilter(null)">&times;</span></span>';
    } else {
      indicatorEl.style.display = "none";
    }
  }

  // Apply status filter
  if (currentStatusFilter) {
    filtered = filtered.filter(s => serviceMatchesStatusFilter(s, currentStatusFilter));
  }

  // Empty state when filter yields no results
  if (filtered.length === 0 && currentStatusFilter) {
    container.innerHTML =
      '<div class="empty-state">' +
      '<div class="empty-icon">&#x2205;</div>' +
      '<div class="empty-text">No services match the "' + escapeHtml(currentStatusFilter) + '" filter</div>' +
      '</div>';
    renderActiveIssues(unified);
    renderMismatchAlerts();
    updateSummary(unified);
    updateBanner(unified);
    return;
  }

  // Group by category
  const groups = {};
  for (const svc of filtered) {
    if (!groups[svc.category]) groups[svc.category] = [];
    groups[svc.category].push(svc);
  }

  for (const cat of CATEGORY_ORDER) {
    const svcs = groups[cat];
    if (!svcs) continue;

    const group = document.createElement("div");
    group.className = "service-group";
    group.innerHTML = '<div class="group-title">' + escapeHtml(cat) + "</div>";

    const card = document.createElement("div");
    card.className = "group-card";

    for (const svc of svcs) {
      card.appendChild(renderServiceRow(svc));
    }

    group.appendChild(card);
    container.appendChild(group);
  }

  renderActiveIssues(unified);
  renderMismatchAlerts();
  updateSummary(unified);
  updateBanner(unified);

  // Show/hide Expand All button
  const dualCount = unified.filter(s => s.global && s.internal).length;
  const expandBtn = document.getElementById("expand-all-btn");
  if (expandBtn) {
    expandBtn.style.display = dualCount > 0 ? "" : "none";
    expandBtn.textContent = allExpanded ? "Collapse All" : "Expand All";
  }
}

function renderServiceRow(svc) {
  const row = document.createElement("div");
  const hasBoth = svc.global && svc.internal;
  const mismatch = hasBoth ? getMismatchType(svc) : null;
  const isExpanded = expandedServices.has(svc.name);
  row.className = "service-row" + (mismatch ? " has-mismatch" : "") + (hasBoth ? " expandable" : "");

  let html = '<div class="service-header">';

  // Name + chevron
  html += '<span class="service-name">';
  if (hasBoth) {
    html += '<span class="expand-icon' + (isExpanded ? " expanded" : "") + '">&#x25B6;</span>';
  }
  if (svc.statusUrl) {
    html += '<a href="' + svc.statusUrl + '" target="_blank" rel="noopener" onclick="event.stopPropagation()">' + escapeHtml(svc.displayName) + '</a>';
  } else {
    html += escapeHtml(svc.displayName);
  }
  html += '</span>';

  // Badges — always show both Global + Ours badges
  html += '<span class="status-badges">';
  if (svc.global) {
    const gl = svc.global.level === "error" ? "unknown" : (svc.global.level || "loading");
    html += '<span class="status-badge badge-' + gl + '">';
    html += '<span class="badge-label">Global</span>';
    html += '<span class="badge-dot"></span>' + capitalize(gl);
    html += '</span>';
  }
  if (svc.internal) {
    const il = svc.internal.level || "unknown";
    const ddUrl = buildDatadogUrl(svc.ddTags || []);
    const isAlerting = il === "major" || il === "degraded" || il === "partial";
    if (il === "unknown") {
      html += '<span class="status-badge badge-unmonitored">';
      html += '<span class="badge-label">Ours</span>';
      html += '<span class="badge-dot"></span>Not Monitored';
      html += '</span>';
    } else if (isAlerting && ddUrl) {
      html += '<a href="' + ddUrl + '" target="_blank" rel="noopener" class="status-badge badge-' + il + '" style="text-decoration:none;cursor:pointer" onclick="event.stopPropagation()" title="View in Datadog">';
      html += '<span class="badge-label">Ours</span>';
      html += '<span class="badge-dot"></span>' + capitalize(il);
      html += '</a>';
    } else {
      html += '<span class="status-badge badge-' + il + '">';
      html += '<span class="badge-label">Ours</span>';
      html += '<span class="badge-dot"></span>' + capitalize(il);
      html += '</span>';
    }
  }
  if (!svc.global && !svc.internal) {
    html += '<span class="status-badge badge-loading"><span class="badge-dot"></span>Loading</span>';
  }
  html += '</span>';
  html += '</div>';

  const days = getLast90Days();

  const isUnmonitored = svc.internal && svc.internal.level === "unknown";

  if (hasBoth) {
    // Merged bar (always visible)
    html += renderMergedBar(days, svc);

    // Expanded dual bars — skip ours bar for unmonitored services
    html += '<div class="bar-detail' + (isExpanded ? " open" : "") + '">';
    html += '<div class="bar-pair">';
    html += renderUptimeBar(days, svc.globalHistoryKey, globalHistory, "Global", "global-label", false);
    if (!isUnmonitored) {
      html += renderUptimeBar(days, svc.internalHistoryKey, internalHistory, "Ours", "ours-label", false);
    }
    html += '</div>';
    html += '</div>';

    // Mismatch indicator
    if (mismatch) {
      html += '<div class="mismatch-inline">';
      if (mismatch === "ours-down") {
        html += '&#x26A0; Our integration is down while vendor is healthy';
      } else if (mismatch === "vendor-down") {
        html += '&#x1F50D; Vendor issue not yet affecting us';
      } else if (mismatch === "both-down") {
        html += '&#x1F6A8; Vendor outage affecting our systems';
      }
      html += '</div>';
    }
  } else if (!isUnmonitored) {
    // Single bar — skip for unmonitored internal-only services
    const histKey = svc.globalHistoryKey || svc.internalHistoryKey;
    const hist = svc.global ? globalHistory : internalHistory;
    const label = svc.internal ? "Ours" : "Global";
    html += renderUptimeBar(days, histKey, hist, label, svc.internal ? "ours-label" : "global-label", true);
  }

  // Footer
  const histKey = svc.globalHistoryKey || svc.internalHistoryKey;
  const hist = svc.global ? globalHistory : internalHistory;
  const history = histKey ? hist[histKey] || {} : {};
  let totalDays = 0, opDays = 0;
  for (const day of days) {
    const ds = history[day];
    if (ds && ds !== "error" && ds !== "unknown") {
      totalDays++;
      if (ds === "operational") opDays++;
    }
  }
  const pct = totalDays > 0 ? ((opDays / totalDays) * 100).toFixed(2) : null;
  const pctClass = pct !== null && parseFloat(pct) >= 99 ? "good" : "";
  const pctText = pct !== null ? pct + "% uptime" : "";
  html += '<div class="uptime-footer">';
  html += '<span>90 days ago</span>';
  html += '<span class="uptime-pct ' + pctClass + '">' + pctText + '</span>';
  html += '<span>Today</span>';
  html += '</div>';

  row.innerHTML = html;

  // Click handler for expand/collapse
  if (hasBoth) {
    row.addEventListener("click", (e) => {
      // Don't toggle when clicking links or badges
      if (e.target.closest("a")) return;
      if (expandedServices.has(svc.name)) {
        expandedServices.delete(svc.name);
      } else {
        expandedServices.add(svc.name);
      }
      // Update allExpanded state
      const unified = buildUnifiedServiceList();
      const dualCount = unified.filter(s => s.global && s.internal).length;
      allExpanded = expandedServices.size >= dualCount;
      const eBtn = document.getElementById("expand-all-btn");
      if (eBtn) eBtn.textContent = allExpanded ? "Collapse All" : "Expand All";
      render();
    });
  }

  return row;
}

function renderUptimeBar(days, historyKey, historyObj, label, labelClass, isSingle) {
  let html = '<div class="bar-label ' + labelClass + '">' + label + '</div>';
  html += '<div class="uptime-bar' + (isSingle ? ' single' : '') + '">';
  const history = historyKey ? historyObj[historyKey] || {} : {};
  for (const day of days) {
    const ds = history[day];
    const barClass = ds ? "bar-" + ds : "bar-unknown";
    const tipStatus = ds ? capitalize(ds) : "No data";
    html += '<div class="bar-segment ' + barClass + '" data-tip="' + label + ': ' + formatDate(day) + " \u2014 " + tipStatus + '"></div>';
  }
  html += '</div>';
  return html;
}

function renderMergedBar(days, svc) {
  const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3, error: -1, unknown: -1, loading: -1 };
  const LEVEL_BY_SEV = ["operational", "degraded", "partial", "major"];
  const gHist = svc.globalHistoryKey ? globalHistory[svc.globalHistoryKey] || {} : {};
  // Skip internal history for unmonitored services — no real data to show
  const isUnmonitored = svc.internal && svc.internal.level === "unknown";
  const iHist = (!isUnmonitored && svc.internalHistoryKey) ? internalHistory[svc.internalHistoryKey] || {} : {};

  let html = '<div class="bar-label" style="color:var(--text-muted)">Combined</div>';
  html += '<div class="uptime-bar single">';
  for (const day of days) {
    const gDay = gHist[day] || "unknown";
    const iDay = iHist[day] || "unknown";
    const gSev = SEVERITY[gDay] ?? -1;
    const iSev = SEVERITY[iDay] ?? -1;
    const worstSev = Math.max(gSev, iSev);
    const level = worstSev >= 0 ? LEVEL_BY_SEV[worstSev] : "unknown";
    const barClass = "bar-" + level;
    const tipG = gDay ? capitalize(gDay) : "No data";
    const tipI = isUnmonitored ? "Not monitored" : (iDay ? capitalize(iDay) : "No data");
    html += '<div class="bar-segment ' + barClass + '" data-tip="' + formatDate(day) + ' \u2014 Global: ' + tipG + ', Ours: ' + tipI + '"></div>';
  }
  html += '</div>';
  return html;
}

function getMismatchType(svc) {
  if (!svc.global || !svc.internal) return null;
  const gl = svc.global.level;
  const il = svc.internal.level;
  if (gl === "loading" || gl === "error") return null;

  const gBad = gl === "major" || gl === "partial" || gl === "degraded";
  const iBad = il === "major" || il === "partial" || il === "degraded";

  if (!gBad && iBad) return "ours-down";
  if (gBad && !iBad) return "vendor-down";
  if (gBad && iBad) return "both-down";
  return null;
}

function renderActiveIssues(unified) {
  const container = document.getElementById("active-issues");
  if (!container) return;

  // Find services with active problems (non-operational, non-unknown, non-loading)
  const problemServices = unified.filter(svc => {
    const levels = [];
    if (svc.global && svc.global.level !== "loading" && svc.global.level !== "error") levels.push(svc.global.level);
    if (svc.internal && svc.internal.level !== "unknown") levels.push(svc.internal.level);
    const worst = getWorstLevel(levels);
    return worst === "major" || worst === "degraded" || worst === "partial";
  });

  if (problemServices.length === 0) {
    container.style.display = "none";
    return;
  }

  const hasOutage = problemServices.some(svc => {
    const levels = [];
    if (svc.global && svc.global.level !== "loading" && svc.global.level !== "error") levels.push(svc.global.level);
    if (svc.internal && svc.internal.level !== "unknown") levels.push(svc.internal.level);
    return getWorstLevel(levels) === "major";
  });

  let html = '<div class="active-issues' + (hasOutage ? '' : ' degraded-only') + '">';
  html += '<div class="active-issues-header" onclick="setStatusFilter(\'degraded\')">';
  html += '<span class="pulse-dot"></span>';
  html += (hasOutage ? 'Active Issues' : 'Degraded Services');
  html += '<span class="issue-count">' + problemServices.length + ' affected</span>';
  html += '</div>';

  for (const svc of problemServices) {
    const levels = [];
    if (svc.global && svc.global.level !== "loading" && svc.global.level !== "error") levels.push(svc.global.level);
    if (svc.internal && svc.internal.level !== "unknown") levels.push(svc.internal.level);
    const worst = getWorstLevel(levels);
    const dotColor = worst === "major" ? "var(--red)" : worst === "partial" ? "var(--orange)" : "var(--yellow)";

    // Build detail text
    const parts = [];
    if (svc.global && svc.global.level !== "operational" && svc.global.level !== "loading" && svc.global.level !== "error") {
      parts.push("Global: " + (svc.global.description || capitalize(svc.global.level)));
    }
    if (svc.internal && svc.internal.level !== "unknown" && svc.internal.level !== "operational") {
      parts.push("Ours: " + (svc.internal.description || capitalize(svc.internal.level)));
    }

    html += '<div class="active-issue-row">';
    html += '<span class="issue-dot" style="background:' + dotColor + '"></span>';
    html += '<span class="issue-name">' + escapeHtml(svc.displayName) + '</span>';
    html += '<span class="issue-detail">' + escapeHtml(parts.join(" · ")) + '</span>';

    // Badges
    html += '<span class="issue-badges">';
    if (svc.global && svc.global.level !== "loading" && svc.global.level !== "error") {
      const gl = svc.global.level;
      html += '<span class="status-badge badge-' + gl + '" style="font-size:0.68rem;padding:0.1rem 0.4rem">';
      html += '<span class="badge-dot" style="width:6px;height:6px"></span>' + capitalize(gl) + '</span>';
    }
    if (svc.internal && svc.internal.level !== "unknown") {
      const il = svc.internal.level;
      const ddUrl = buildDatadogUrl(svc.ddTags || []);
      if ((il === "major" || il === "degraded" || il === "partial") && ddUrl) {
        html += '<a href="' + ddUrl + '" target="_blank" rel="noopener" class="status-badge badge-' + il + '" style="font-size:0.68rem;padding:0.1rem 0.4rem;text-decoration:none">';
        html += '<span class="badge-dot" style="width:6px;height:6px"></span>' + capitalize(il) + '</a>';
      } else {
        html += '<span class="status-badge badge-' + il + '" style="font-size:0.68rem;padding:0.1rem 0.4rem">';
        html += '<span class="badge-dot" style="width:6px;height:6px"></span>' + capitalize(il) + '</span>';
      }
    }
    html += '</span>';
    html += '</div>';
  }

  html += '</div>';
  container.style.display = "block";
  container.innerHTML = html;
}

function renderMismatchAlerts() {
  const container = document.getElementById("mismatch-alerts");
  const mismatches = detectMismatches();
  container.innerHTML = "";

  // Only show ours-down as prominent alerts (most actionable)
  const oursDown = mismatches.filter(m => m.type === "ours-down");
  for (const m of oursDown) {
    const div = document.createElement("div");
    div.className = "mismatch-alert mismatch-ours-down";
    div.innerHTML =
      '<span class="alert-icon">&#x26A0;</span>' +
      '<span class="alert-text"><strong>' + escapeHtml(m.message) + '</strong>' +
      '<span class="alert-detail">' + escapeHtml(m.detail) + '</span></span>';
    container.appendChild(div);
  }
}

function updateSummary(unified) {
  // Mutually exclusive counts: each service counted once (outage > degraded > operational)
  let up = 0, degraded = 0, outage = 0;
  for (const svc of unified) {
    const worst = getServiceWorstKnownLevel(svc);
    if (worst === "major") outage++;
    else if (worst === "degraded" || worst === "partial") degraded++;
    else up++;
  }

  const els = { "count-up": up, "count-degraded": degraded, "count-outage": outage };
  for (const [id, val] of Object.entries(els)) {
    const el = document.getElementById(id);
    if (el) el.textContent = val;
  }
}

function getWorstLevel(levels) {
  const SEVERITY = { operational: 0, degraded: 1, partial: 2, major: 3, unknown: -1 };
  let worst = "unknown";
  let worstSev = -1;
  for (const l of levels) {
    const s = SEVERITY[l] ?? -1;
    if (s > worstSev) { worst = l; worstSev = s; }
  }
  return worst;
}

function updateBanner(unified) {
  const banner = document.getElementById("overall-banner");
  const text = document.getElementById("overall-text");

  const allLevels = [];
  for (const svc of unified) {
    if (svc.global && svc.global.level !== "loading" && svc.global.level !== "error") allLevels.push(svc.global.level);
    if (svc.internal) allLevels.push(svc.internal.level);
  }

  if (allLevels.length === 0) {
    banner.className = "overall-banner banner-loading";
    text.textContent = "Checking system status\u2026";
    return;
  }

  const hasOutage = allLevels.includes("major");
  const hasDegraded = allLevels.includes("degraded") || allLevels.includes("partial");
  const mismatches = detectMismatches();
  const oursDown = mismatches.filter(m => m.type === "ours-down");

  if (hasOutage) {
    banner.className = "overall-banner banner-outage";
    text.textContent = "Major outage detected on one or more services";
  } else if (oursDown.length > 0) {
    banner.className = "overall-banner banner-outage";
    text.textContent = oursDown.length + " service(s) with integration issues \u2014 vendors are healthy";
  } else if (hasDegraded) {
    banner.className = "overall-banner banner-degraded";
    text.textContent = "Some systems are experiencing issues";
  } else {
    banner.className = "overall-banner banner-operational";
    text.textContent = "All systems operational";
  }
}

function renderError(msg) {
  const banner = document.getElementById("overall-banner");
  const text = document.getElementById("overall-text");
  banner.className = "overall-banner banner-outage";
  text.textContent = msg;
}

function renderInternalError(msg) {
  const el = document.getElementById("internal-error");
  if (!el) return;
  el.style.display = "block";
  el.innerHTML =
    '<span style="margin-right:0.4rem">!</span>' +
    'Internal status unavailable: ' + escapeHtml(msg) +
    (IS_LOCAL ? ' &mdash; is local-server.py running?' : '');
}

function updateDataSourceBadge(data) {
  const badge = document.getElementById("data-source-badge");
  if (!badge) return;
  badge.style.display = "";
  if (data.mock) {
    badge.className = "badge-data-source badge-mock";
    badge.textContent = "Mock Data";
    badge.title = data.datadog_error
      ? "Datadog error: " + data.datadog_error + ". Showing mock data."
      : "DD_API_KEY / DD_APP_KEY not configured. Showing mock data.";
  } else {
    badge.className = "badge-data-source badge-live";
    badge.textContent = "Live";
    badge.title = "Connected to Datadog API";
  }
}

// ── Countdown ───────────────────────────────────────────────────────────

function startCountdown() {
  if (countdownTimer) clearInterval(countdownTimer);
  countdownTimer = null;
  countdownSeconds = REFRESH_INTERVAL;
  countdownTimer = setInterval(() => {
    countdownSeconds--;
    const el = document.getElementById("countdown");
    if (el) el.textContent = "Refreshing in " + countdownSeconds + "s";
    if (countdownSeconds <= 0) {
      countdownSeconds = REFRESH_INTERVAL;
      refreshAll();
    }
  }, 1000);
}

// ── Init ────────────────────────────────────────────────────────────────

initAuth();
</script>
</body>
</html>
